<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C# 解压压缩包及 7z 库缺失导致 Can not load 7-zip library or internal COM error!]]></title>
    <url>%2F2018%2F11%2F07%2FCSharpUnzipAnd7zLibraryMissingError%2F</url>
    <content type="text"><![CDATA[表现C# 程序解压 7z 文件的时候抛出异常 1Can not load 7-zip library or internal COM error! Message: DLL file does not exist. 原因程序无法找到 7z 库，导致无法解压 7z 文件 解决在官网 Download 7-Zip 下载下面的 7z 库 Link Type Windows Description Download .7z x86 / x64 7-Zip Extra: standalone console version, 7z DLL, Plugin for Far Manager 解压重命名到 C:\Program Files\7-Zip 使用1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 解压压缩包/// &lt;/summary&gt;/// &lt;param name="file_path"&gt;压缩包路径&lt;/param&gt;/// &lt;param name="save_path"&gt;解压后保存路径&lt;/param&gt;/// &lt;returns&gt;是否解压成功&lt;/returns&gt;private bool UncompressFile(string file_path, string save_path)&#123; try &#123; if (System.IO.Directory.Exists(save_path)) &#123; System.IO.Directory.Delete(save_path, true); &#125; SevenZip.SevenZipExtractor.SetLibraryPath(@"C:\Program Files\7-Zip\7za.dll"); SevenZip.SevenZipExtractor extractor = new SevenZip.SevenZipExtractor(file_path); extractor.ExtractArchive(save_path); extractor.Dispose(); &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine(e1.Message); return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Dotnet</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技嘉Z370 HD3P + i7-8700K + GTX1080 装黑苹果 High Sierra 10.13.6]]></title>
    <url>%2F2018%2F10%2F13%2FGIGABYTE_Z370_HD3P_i7-8700K_GTX1080_Install_Hackintosh_HighSierra10.13.6%2F</url>
    <content type="text"><![CDATA[前言本博文记录了组装台式机装黑苹果 High Sierra 10.13.6 的经历。 原本想装 Mojave 10.14 的，可惜发现在 Mojave 下还没有 GTX1080 的驱动，所以只能退而求其次装 High Sierra 了。 装 High Sierra 的过程中，第一次使用 10.13.6(17G2112) 镜像遇到个问题（下文有描述），无法进入安装界面，因此后来使用 10.13.5(17F77) 镜像装好后在 AppStore 更新 10.13.6 配置 主板：技嘉 Z370 HD3P CPU：Intel Core i7-8700K 核显：Intel UHD Graphics 630 独显：七彩虹 iGame GTX1080 Vulcan X 8G 内存：海盗船复仇者 DDR4 3200 8G*2 固态硬盘：三星 SSD 970 EVO 250GB（Windows） 机械硬盘：西数 WD10EZEX 7200PPM 64M 1T（EFI + MacOS + Storage） 板载音频：Realtek ALC1220 板载网卡：Intel I219V2 PCI Express Gigabit Ethernet USB蓝牙：绿联 CSR8891 USB蓝牙 4.0 文件本博文使用的一些软件工具驱动，下文则不赘述。 带 Clover 镜像 10.13.6(17G2112) 镜像：macOS High Sierra 10.13.6(17G2112) Installer with Clover 4606.dmg 10.13.5(17F77)镜像：macOS High Sierra 10.13.5(17F77) Installer with Clover 4512.dmg EFI 分区 huihut . Hackintosh-Z370/EFI 工具 U盘刻录工具 Etcher：官网 | 百度网盘 Clover 配置工具 Clover Configurator：官网 | 百度网盘 内核注入工具 Kext Wizard：网络 | 百度网盘 文本编辑器 BBEdit 12：官网 | 百度网盘 驱动 驱动安装工具 MultiBeast 10.4.0 - High Sierra：官网 | 百度网盘 Nvidia Web 驱动 387.10.10.10.40.105（适用于 10.13.6）：官网 | 百度网盘 Nvidia Web 驱动 387.10.10.10.35.106（适用于 10.13.5）：官网 | 百度网盘 刻录镜像准备一个8G以上的U盘，使用 Etcher 刻录上面下载的镜像（带有 Clover EFI 分区）：macOS High Sierra 10.13.6(17G2112) Installer with Clover 4606.dmg 设置 BIOS BIOS 版本已更新为 F7 Save &amp; Exit -&gt; Load Optimized Defaults : Yes M.I.T. -&gt; Advanced Memory Settings -&gt; Extreme Memory Profile(X.M.P.) : Profile 1 BIOS -&gt; Fast Boot : Disabled BIOS -&gt; CSM Support : Disabled Peripherals -&gt; Super IO Configuration -&gt; Serial Port : Disabled Peripherals -&gt; USB Configuration -&gt; XHCI Hand-off : Enabled Chipset -&gt; Vt-d : Disabled 保存 BIOS 配置 引导出错重启进入刻录好的U盘，选择 Boot macOS Install from Install macOS High Sierra 唠叨模式滚代码的时候出错：please go to https://panic.apple.com to report this panic 重新刻录上面的问题 Google 了一圈并未发现解决办法，因此重新刻录 macOS High Sierra 10.13.5(17F77) Installer with Clover 4512.dmg，先装 10.13.5(17F77) 。 引导安装这次的 10.13.5(17F77) 成功进入安装界面了。 打开磁盘工具，格好一个系统盘，格式为 APFS 或者 Mac OS 扩展（日志式），大小因人而异，我留了 128G。 格好后安装系统到这个盘。 安装过程中第一次自动重启依然进入 U 盘 Clover，引导进入格出来的盘继续安装。 第二次自动重启也是进入 U 盘 Clover，引导进入格出来的盘，然后安装完毕进入系统。 安装 CloverClover 选择进入系统后发现 1080 独显不能驱动、八代 CPU 不能识别，这个先不管，先装 Clover 到磁盘的 EFI 分区。 安装 Clover 有两种： 使用原版 CLover：Clover EFI bootloader 官方下载 使用 U 盘 EFI 分区的 Clover 由于 U 盘的 Clover 是已经试验过能引导的，所以我就用了 U 盘的。 挂载 EFI 分区在终端上执行 diskutil list，找到两个 EFI 分区（磁盘的 EFI 和 U 盘的 EFI），如下的 disk0 s1 和 disk3 s1 123456789101112131415161718192021222324252627282930313233HuiMac:~ huihut$ diskutil list/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *1.0 TB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk2 128.8 GB disk0s2 3: Microsoft Basic Data Document 85.9 GB disk0s3 4: Microsoft Basic Data Software 161.1 GB disk0s4 5: Microsoft Basic Data Data 624.2 GB disk0s5/dev/disk1 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 250.1 GB disk1 1: Microsoft Reserved 16.8 MB disk1s1 2: Microsoft Basic Data 249.2 GB disk1s2 3: Windows Recovery 847.2 MB disk1s3/dev/disk2 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +128.8 GB disk2 Physical Store disk0s2 1: APFS Volume MacOS 84.8 GB disk2s1 2: APFS Volume Preboot 67.7 MB disk2s2 3: APFS Volume Recovery 1.0 GB disk2s3 4: APFS Volume VM 20.5 KB disk2s4/dev/disk3 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *31.0 GB disk3 1: EFI EFI 209.7 MB disk3s1 2: Apple_HFS Install macOS High S... 5.7 GB disk3s2HuiMac:~ huihut$ 分别挂载到不同名字的卷 挂载磁盘 EFI12sudo mkdir /Volumes/efidisksudo mount -t msdos /dev/disk0s1 /Volumes/efidisk 挂载 U 盘 EFI12sudo mkdir /Volumes/efiusbsudo mount -t msdos /dev/disk3s1 /Volumes/efiusb 复制 Clover然后把 U 盘的 EFI/CLOVER 这个文件夹复制到 磁盘的 EFI 下 安装驱动使用 MultiBeast 安装驱动，使用 Nvidia WebDriver 安装显卡驱动（MultiBeast 的 WebDriver 不能驱动我的 1080）。 装好 Nvidia WebDriver 后 1080 能驱动，不过 i7-8700K 的八代 CPU 还是不能识别，先不管，在 AppStore 更新 10.13.6。 更新后安装驱动更新完 10.13.6 发现许多驱动有问题： 独显无法驱动 CPU无法识别 声卡无法驱动 USB3.0无法驱动 驱动独显使用适用于 10.13.6 的 WebDriver-387.10.10.10.40.105.pkg，装好重启后就 OK 了 修复 CPU 识别 参见 八代处理器安装黑苹果 关于本机显示“未知”解决办法 挂载磁盘 EFI 分区（操作如上），使用 Clover Configurator 打开 /EFI/CLOVER/config.plist 在 CPU 页面的 Type 中填入 Unknown，保存。 使用文本编辑器（如 BBEdit）打开 /System/Library/PrivateFrameworks/AppleSystemInfo.framework/Versions/A/Resources/zh_CN.lproj/AppleSystemInfo.strings 文件 修改 UnknownCPUKind 的值为 3.7 GHz Intel Core i7-8700K 保存重启即可。 修复声卡驱动 参见 黑苹果AppleALC声卡驱动安装使用教程 我使用 MultiBeast 安装的 ALC1220 驱动在 10.13.6 下不能驱动我的声卡，试过 MultiBeast 的其他驱动也不行，因此使用另一种方法修复。 在 acidanthera/AppleALC/releases 下载最新的 AppleALC 的 RELEASE 版 AppleALC.kext，使用 Kext Wizard 注入这个内核，如下图 然后挂载磁盘 EFI 分区（操作如上），把 AppleALC.kext 放入磁盘 EFI 分区的 EFI/CLOVER/kexts/Other/目录中。 然后在 acidanthera/AppleALC/Resources 找到你的声卡型号的文件夹，进入（如我的是 ALC1220）。 我的声卡型号看到有 layout1.xml、layout2.xml、layout5.xml、layout7.xml、layout11.xml、layout13.xml 然后在 1、2、5、7、11、13 中随便取一个数。 使用文本编辑器打开磁盘 EFI 分区的 EFI/CLOVER/config.plist 文件，搜索 &lt;key&gt;Audio&lt;/key&gt;，把它的 integer 改为刚刚取的那个数（如 1）。 保存重启即可。 修复 USB3.0 参见 HACKINTOSH HIGH SIERRA 10.13.6 UPDATE GUIDE 使用上文描述的操作挂载磁盘的 EFI 分区 使用 Clover Configurator 打开 /EFI/CLOVER/config.plist 如下图，插入（若已存在则修改为）配置信息 Name*: com.apple.driver.usb.AppleUSBXHCI Find* [HEX]: 837D880F 0F83A704 0000 Replace* [HEX]: 837D880F 90909090 9090 Comment: USB 10.13.6+ by PMHeart MatchOS: 10.13.x 保存重启即可。 蓝牙免驱 iMessage、序列号问题 参见 [Hackintosh]解决黑苹果无法使用Siri、iMessage等服务 更换Clover主题Clover主题可以到官方仓库下载： Clover Theme Repository 也可以使用其他的，比如我使用这个简洁风格的： Clover Minimal - A clean theme for the Clover UEFI bootloader 只需下载下来，放到 /EFI/CLOVER/themes 文件夹下，然后使用 Clover Configurator 打开 /EFI/CLOVER/config.plist 更换到这个主题就好啦。 另外这个显示启动盘的标签的 Label 建议勾上，这样才知道选择的是哪个盘，保存重启即可。 感谢 tonymacx86 黑果小兵的部落阁 黑苹果乐园 [Success] Gigabyte Z370 HD3P - i7 8700K - Gigabyte RX580 4GB - Mojave 10.14.0 Building a GTX 1080 Ti-powered Hackintosh: Installing macOS Sierra step-by-step [Video]]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyparsing 无法卸载导致安装 matplotlib 出错]]></title>
    <url>%2F2018%2F10%2F13%2FPyparsingFailsToUninstallCausingErrorInInstallingMatplotlib%2F</url>
    <content type="text"><![CDATA[表现1sudo pip install matplotlib 安装 matplotlib 时出现以下错误 12 Found existing installation: pyparsing 1.5.6Cannot uninstall &apos;pyparsing&apos;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall. 原因安装 matplotlib 需要卸载我已安装的 1.5.6 版本的 pyparsing，再重新装新版本，但是无法卸载 解决手动重装最新版 pyparsing 首先，去官网查看最新版是什么版本：https://pypi.org/project/pyparsing/ 当前最新版是 pyparsing 2.2.0，所以执行如下重新安装最新版： 1sudo pip install -I pyparsing==2.2.0]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-dev 库缺失导致安装 matplotlib 出错]]></title>
    <url>%2F2018%2F10%2F13%2FMissingPython-devCausesErrorInInstallingMatplotlib%2F</url>
    <content type="text"><![CDATA[表现1sudo pip install matplotlib 安装 matplotlib 时出现以下错误 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Installing collected packages: subprocess32, cycler, backports.functools-lru-cache, pyparsing, kiwisolver, matplotlib Running setup.py install for subprocess32 ... error Complete output from command /usr/bin/python2 -u -c &quot;import setuptools, tokenize;__file__=&apos;/tmp/pip-install-azXKeu/subprocess32/setup.py&apos;;f=getattr(tokenize, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, &apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; install --record /tmp/pip-record-5SM9_6/install-record.txt --single-version-externally-managed --compile: /usr/lib64/python2.7/distutils/dist.py:267: UserWarning: Unknown distribution option: &apos;python_requires&apos; warnings.warn(msg) running install running build running build_py creating build creating build/lib.linux-x86_64-2.7 copying subprocess32.py -&gt; build/lib.linux-x86_64-2.7 running build_ext running build_configure checking for gcc... gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether gcc accepts -g... yes checking for gcc option to accept ISO C89... none needed checking how to run the C preprocessor... gcc -E checking for grep that handles long lines and -e... /bin/grep checking for egrep... /bin/grep -E checking for ANSI C header files... yes checking for sys/types.h... yes checking for sys/stat.h... yes checking for stdlib.h... yes checking for string.h... yes checking for memory.h... yes checking for strings.h... yes checking for inttypes.h... yes checking for stdint.h... yes checking for unistd.h... yes checking for unistd.h... (cached) yes checking fcntl.h usability... yes checking fcntl.h presence... yes checking for fcntl.h... yes checking signal.h usability... yes checking signal.h presence... yes checking for signal.h... yes checking sys/cdefs.h usability... yes checking sys/cdefs.h presence... yes checking for sys/cdefs.h... yes checking for sys/types.h... (cached) yes checking for sys/stat.h... (cached) yes checking sys/syscall.h usability... yes checking sys/syscall.h presence... yes checking for sys/syscall.h... yes checking for dirent.h that defines DIR... yes checking for library containing opendir... none required checking for pipe2... yes checking for setsid... yes checking whether dirfd is declared... yes configure: creating ./config.status config.status: creating _posixsubprocess_config.h building &apos;_posixsubprocess32&apos; extension creating build/temp.linux-x86_64-2.7 gcc -pthread -fno-strict-aliasing -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -D_GNU_SOURCE -fPIC -fwrapv -DNDEBUG -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -D_GNU_SOURCE -fPIC -fwrapv -fPIC -I/usr/include/python2.7 -c _posixsubprocess.c -o build/temp.linux-x86_64-2.7/_posixsubprocess.o _posixsubprocess.c:16:20: fatal error: Python.h: No such file or directory #include &quot;Python.h&quot; ^ compilation terminated. error: command &apos;gcc&apos; failed with exit status 1 原因无法找到 python 库，#include &quot;Python.h&quot; 出错 解决 使用 apt (Ubuntu, Debian…) 安装 12sudo apt-get install python-dev # for python2.x installssudo apt-get install python3-dev # for python3.x installs 使用 yum (CentOS, RHEL…) 安装 12sudo yum install python-devel # for python2.x installssudo yum install python34-devel # for python3.4 installs 使用 dnf (Fedora…) 安装 12sudo dnf install python2-devel # for python2.x installssudo dnf install python3-devel # for python3.x installs 使用 zypper (openSUSE…) 安装 12sudo zypper in python-devel # for python2.x installssudo zypper in python3-devel # for python3.x installs 使用 apk (Alpine…) 安装 12sudo apk add python2-dev # for python2.x installssudo apk add python3-dev # for python3.x installs]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinRT(C++/CX) UTF8类型转换为std::string和Platform::String^的Unicode字符串]]></title>
    <url>%2F2018%2F08%2F23%2FUTF8ToStdStrAndUTF8ToManagedStr%2F</url>
    <content type="text"><![CDATA[Gist 仓库地址：https://gist.github.com/huihut/8f75e2332e05673ff7e1248ad5e85339 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;string&gt;#include &lt;Windows.h&gt;std::string UTF8_To_Std_Str(const std::string &amp; str)&#123; int nwLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0); wchar_t* pwBuf = new wchar_t[nwLen + 1]; memset(pwBuf, 0, nwLen * 2 + 2); MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.length(), pwBuf, nwLen); int nLen = WideCharToMultiByte(CP_ACP, 0, pwBuf, -1, NULL, NULL, NULL, NULL); char* pBuf = new char[nLen + 1]; memset(pBuf, 0, nLen + 1); WideCharToMultiByte(CP_ACP, 0, pwBuf, nwLen, pBuf, nLen, NULL, NULL); std::string retStr = pBuf; delete[] pBuf; delete[] pwBuf; pBuf = NULL; pwBuf = NULL; return retStr;&#125;Platform::String^ UTF8_To_Managed_Str(const std::string &amp; str)&#123; int nwLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0); wchar_t* pwBuf = new wchar_t[nwLen + 1]; memset(pwBuf, 0, nwLen * 2 + 2); MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.length(), pwBuf, nwLen); Platform::String^ pStr = ref new Platform::String(pwBuf); delete[] pwBuf; pwBuf = NULL; return pStr;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinRT(C++/CX) Platform::String^ 与 std::string 的类型转换]]></title>
    <url>%2F2018%2F08%2F23%2FTypeConversionBetweenPlatformStringAndStdstring%2F</url>
    <content type="text"><![CDATA[Gist 仓库地址：https://gist.github.com/huihut/aa90bd3a202090e25b9a4792c80e6920 1234567891011121314#include &lt;string&gt;std::string Managed_Str_To_Std_Str(Platform::String^ ms)&#123; std::wstring w_str(ms-&gt;Begin()); return std::string(w_str.begin(), w_str.end());&#125;Platform::String^ Std_Str_To_Managed_Str(const std::string &amp; input)&#123; std::wstring w_str = std::wstring(input.begin(), input.end()); const wchar_t* w_chars = w_str.c_str(); return (ref new Platform::String(w_chars));&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV使用CMake和MinGW-w64的编译安装]]></title>
    <url>%2F2018%2F07%2F31%2FCompiledOpenCVWithMinGW64%2F</url>
    <content type="text"><![CDATA[前言之前写过的一篇博文：OpenCV使用CMake和MinGW的编译安装及其在Qt配置运行 是使用 32 位的 MinGW 在 Windows 下编译 OpenCV 生成 32 位的 dll。 而这篇博文是使用 64 位的 MinGW 编译 OpenCV 生成 64 位的 dll。 因为博主没有 64 位 qmake，所以没勾选 WITH_QT 2018年10月13日为 OpenCV-4.0.0-alpha 而修改，主要改了 “编译 OpenCV 常见错误” 编译好的 OpenCV（MinGW 版）：Github . huihut/OpenCV-MinGW-Build 软件环境 Windows-10-64bit MinGW-x64-4.8.1-release-posix-seh-rev5 CMake-3.12.0 OpenCV-3.4.1 | OpenCV-4.0.0-alpha（适用） 安装 MinGW-w64 并配置环境变量下载安装：MinGW-x64-4.8.1-release-posix-seh-rev5 为系统（用户）变量 Path 添加 E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\bin 使用 CMake 生成 OpenCV 的 Makefile打开 cmake-gui，设置源码和生成路径： Where is the source code: E:/opencv_341/opencv/sources Where to build the binaries: E:/opencv_341/opencv_mingw64_build 点击 Configure，设置编译器 Specify the generator for this project: MinGW Makefiles Specify native compilers Next Compilers C: E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\bin\gcc.exe Compilers C++: E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\bin\g++.exe Finish 编译配置： 勾选 WITH_OPENGL 勾选 ENABLE_CXX11 不勾选 WITH_IPP 不勾选 ENABLE_PRECOMPILED_HEADERS 点击 Configure，Generate 生成 Makefile 博主的配置信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106General configuration for OpenCV 3.4.1 ===================================== Version control: unknown Platform: Timestamp: 2018-07-31T02:14:11Z Host: Windows 10.0.17134 AMD64 CMake: 3.12.0 CMake generator: MinGW Makefiles CMake build tool: E:/MinGW-w64/x64-4.8.1-release-posix-seh-rev5/mingw64/bin/mingw32-make.exe Configuration: Release CPU/HW features: Baseline: SSE SSE2 SSE3 requested: SSE3 Dispatched code generation: SSE4_1 SSE4_2 FP16 AVX AVX2 requested: SSE4_1 SSE4_2 AVX FP16 AVX2 AVX512_SKX SSE4_1 (3 files): + SSSE3 SSE4_1 SSE4_2 (1 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 (2 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 AVX AVX (5 files): + SSSE3 SSE4_1 POPCNT SSE4_2 AVX AVX2 (9 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 FMA3 AVX AVX2 C/C++: Built as dynamic libs?: YES C++11: YES C++ Compiler: E:/MinGW-w64/x64-4.8.1-release-posix-seh-rev5/mingw64/bin/g++.exe (ver 4.8.1) C++ flags (Release): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wuninitialized -Winit-self -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG -DNDEBUG C++ flags (Debug): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wuninitialized -Winit-self -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -fvisibility-inlines-hidden -g -O0 -DDEBUG -D_DEBUG C Compiler: E:/MinGW-w64/x64-4.8.1-release-posix-seh-rev5/mingw64/bin/gcc.exe C flags (Release): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wuninitialized -Winit-self -Wno-narrowing -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -O3 -DNDEBUG -DNDEBUG C flags (Debug): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wuninitialized -Winit-self -Wno-narrowing -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -g -O0 -DDEBUG -D_DEBUG Linker flags (Release): -Wl,--gc-sections Linker flags (Debug): -Wl,--gc-sections ccache: NO Precompiled headers: NO Extra dependencies: opengl32 glu32 3rdparty dependencies: OpenCV modules: To be built: calib3d core dnn features2d flann highgui imgcodecs imgproc java_bindings_generator ml objdetect photo python_bindings_generator shape stitching superres ts video videoio videostab Disabled: js world Disabled by dependency: - Unavailable: cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python2 python3 viz Applications: tests perf_tests apps Documentation: NO Non-free algorithms: NO Windows RT support: NO GUI: Win32 UI: YES OpenGL support: YES (opengl32 glu32) VTK support: NO Media I/O: ZLib: build (ver 1.2.11) JPEG: build (ver 90) WEBP: build (ver encoder: 0x020e) PNG: build (ver 1.6.34) TIFF: build (ver 42 - 4.0.9) JPEG 2000: build (ver 1.900.1) OpenEXR: build (ver 1.7.1) Video I/O: Video for Windows: YES DC1394: NO FFMPEG: YES (prebuilt binaries) avcodec: YES (ver 57.107.100) avformat: YES (ver 57.83.100) avutil: YES (ver 55.78.100) swscale: YES (ver 4.8.100) avresample: YES (ver 3.7.0) GStreamer: NO DirectShow: YES Parallel framework: none Trace: YES (built-in) Other third-party libraries: Lapack: NO Eigen: NO Custom HAL: NO Protobuf: build (3.5.1) NVIDIA CUDA: NO OpenCL: YES (no extra features) Include path: E:/opencv_341/opencv/sources/3rdparty/include/opencl/1.2 Link libraries: Dynamic load Python (for build): E:/Python37-32/python.exe Java: ant: NO JNI: C:/Program Files (x86)/Java/jdk1.8.0_181/include C:/Program Files (x86)/Java/jdk1.8.0_181/include/win32 C:/Program Files (x86)/Java/jdk1.8.0_181/include Java wrappers: NO Java tests: NO Matlab: NO Install to: E:/opencv_341/opencv_mingw64_build/install-----------------------------------------------------------------Configuring doneGenerating done 编译 OpenCV打开终端进行编译：（-j 是使用 8 个线程进行编译，请根据你的计算机配置合理设置线程数） 1234E:cd E:\opencv_341\opencv_mingw64_buildmingw32-make -j 8mingw32-make install 如果 mingw32-make -j 8 遇到错误，请看下面的 编译 OpenCV 常见错误，否则执行 mingw32-make install，完成安装。 编译 OpenCV 常见错误1. MinGW-w64 的 aviriff.h 文件注释错误表现12345678910111213141516171819[ 49%] Building CXX object modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.objIn file included from E:\opencv_341\opencv\sources\modules\videoio\src\cap_dshow.cpp:113:0:e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h:2:8: error: expected constructor, destructor, or type conversion before &apos;file&apos; * This file is part of the mingw-w64 runtime package. ^e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h:3:25: error: &apos;refer&apos; does not name a type * No warranty is given; refer to the file DISCLAIMER within this package. ^In file included from e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h:19:0, from E:\opencv_341\opencv\sources\modules\videoio\src\cap_dshow.cpp:113:e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\pshpack2.h:7:21: error: expected declaration before end of line #pragma pack(push,2) ^modules\videoio\CMakeFiles\opencv_videoio.dir\build.make:146: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj&apos; failedmingw32-make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj] Error 1CMakeFiles\Makefile2:3057: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/all&apos; failedmingw32-make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决打开E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h 发现第一行的多行注释少了个/符号，加上保存，如下： 1234/*** This file is part of the mingw-w64 runtime package.* No warranty is given; refer to the file DISCLAIMER within this package.*/ 然后重新 Configure-Generate-mingw32-make 就好了。 2. cap_msmf.cpp capture code 错误【2018年10月13日修改，因编译 OpenCV-4.0.0-alpha 时遇到并解决】表现12345678910111213141516171819202122232425262728293031......E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;HRESULT &#123;anonymous&#125;::ComPtr&lt;T&gt;::As(&#123;anonymous&#125;::ComPtr&lt;U&gt;&amp;) const [with U = IMF2DBuffer; T = IMFMediaBuffer; HRESULT = long int]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:172:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::operator-&gt;() const [with T = IMF2DBuffer]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:149:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::operator-&gt;() const [with T = IMFMediaBuffer]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:149:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::operator-&gt;() const [with T = IMFSinkWriter]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:149:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::Get() const [with T = IMFMediaBuffer]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:158:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^cc1plus.exe: some warnings being treated as errorsmodules\videoio\CMakeFiles\opencv_videoio.dir\build.make:188: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_msmf.cpp.obj&apos; failedmingw32-make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_msmf.cpp.obj] Error 1CMakeFiles\Makefile2:2556: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/all&apos; failedmingw32-make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2mingw32-make[1]: *** Waiting for unfinished jobs....[ 58%] Linking CXX shared library ..\..\bin\libopencv_dnn400.dll[ 59%] Built target opencv_dnnMakefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 原因因为 MinGW 不能编译 OpenCV 的 cap_msmf 那部分代码，具体见我提的 Issue：Failed to compile opencv-4.0.0-alpha using mingw-w64。 解决所以，在 cmake-gui 编译配置中： 不勾选 WITH_MSMF 然后重新 Configure-Generate-mingw32-make 3. ‘M_PI’ was not declared in this scope 错误【2018年10月13日修改，因编译 OpenCV-4.0.0-alpha 时遇到并解决】表现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[ 86%] Building CXX object modules/calib3d/CMakeFiles/opencv_calib3d.dir/src/chessboard.cpp.objIn file included from E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:7:0:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.hpp: In constructor &apos;cv::details::FastX::Parameters::Parameters()&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.hpp:35:36: error: &apos;M_PI&apos; was not declared in this scope resolution = float(M_PI*0.25); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: At global scope:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:25:42: error: &apos;M_PI&apos; was not declared in this scope const float MAX_ANGLE = float(48.0/180.0*M_PI); // max angle between line segments supposed to be straight ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:26:48: error: &apos;M_PI&apos; was not declared in this scope const float MIN_COS_ANGLE = float(cos(35.0/180*M_PI)); // min cos angle between board edges ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:29:35: error: &apos;M_PI&apos; was not declared in this scope const float RAD2DEG = float(180.0/M_PI); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In function &apos;int cv::details::testPointSymmetry(cv::Mat, cv::Point2f, float, float)&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:217:33: error: &apos;M_PI&apos; was not declared in this scope for(double angle=0;angle &lt;= M_PI;angle+=M_PI*0.1) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::FastX::rotate(float, const cv::Mat&amp;, cv::Size, cv::Mat&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:287:110: error: &apos;M_PI&apos; was not declared in this scope cv::Mat m = cv::getRotationMatrix2D(cv::Point2f(float(img.cols*0.5),float(img.rows*0.5)),float(angle/M_PI*180),1); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;std::vector&lt;std::vector&lt;float&gt; &gt; cv::details::FastX::calcAngles(const std::vector&lt;cv::Mat&gt;&amp;, std::vector&lt;cv::KeyPoint&gt;&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:393:30: error: &apos;M_PI&apos; was not declared in this scope float resolution = float(M_PI/channels); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::FastX::detectImpl(const cv::Mat&amp;, std::vector&lt;cv::Mat&gt;&amp;, std::vector&lt;cv::Mat&gt;&amp;, const cv::Mat&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:631:30: error: &apos;M_PI&apos; was not declared in this scope int num = int(0.5001*M_PI/parameters.resolution); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::Ellipse::draw(cv::InputOutputArray, const Scalar&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:721:43: error: &apos;M_PI&apos; was not declared in this scope cv::ellipse(img,center,axes,360-angle/M_PI*180,0,360,color); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In static member function &apos;static float cv::details::Chessboard::Board::findMaxPoint(cv::flann::Index&amp;, const cv::Mat&amp;, const cv::details::Ellipse&amp;, float, float, cv::Point2f&amp;)&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:1541:17: error: &apos;M_PI&apos; was not declared in this scope if(a1 &gt; M_PI*0.5) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:1543:16: error: &apos;M_PI&apos; was not declared in this scope if(a2&gt; M_PI*0.5) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In static member function &apos;static bool cv::details::Chessboard::Board::estimateSearchArea(const Point2f&amp;, const Point2f&amp;, const Point2f&amp;, float, cv::details::Ellipse&amp;, const Point2f*)&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:1787:28: error: &apos;M_PI&apos; was not declared in this scope angle = float(2.0F*M_PI-angle); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::Chessboard::findKeyPoints(const cv::Mat&amp;, std::vector&lt;cv::KeyPoint&gt;&amp;, std::vector&lt;cv::Mat&gt;&amp;, std::vector&lt;std::vector&lt;float&gt; &gt;&amp;, const cv::Mat&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2793:29: error: &apos;M_PI&apos; was not declared in this scope para.resolution = float(M_PI*0.25); // this gives the best results taking interpolation into account ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;cv::Mat cv::details::Chessboard::buildData(const std::vector&lt;cv::KeyPoint&gt;&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2844:30: error: &apos;M_PI&apos; was not declared in this scope (*val++) = float(2.0*M_PI-iter-&gt;angle/180.0*M_PI); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;std::vector&lt;cv::KeyPoint&gt; cv::details::Chessboard::getInitialPoints(cv::flann::Index&amp;, const cv::Mat&amp;, const cv::KeyPoint&amp;, float, float, float) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2874:25: error: &apos;M_PI&apos; was not declared in this scope if(angle_temp &gt; M_PI*0.5) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2879:29: error: &apos;M_PI&apos; was not declared in this scope if(angle_temp &gt; M_PI*0.5) ^modules\calib3d\CMakeFiles\opencv_calib3d.dir\build.make:137: recipe for target &apos;modules/calib3d/CMakeFiles/opencv_calib3d.dir/src/chessboard.cpp.obj&apos; failedmingw32-make[2]: *** [modules/calib3d/CMakeFiles/opencv_calib3d.dir/src/chessboard.cpp.obj] Error 1CMakeFiles\Makefile2:3018: recipe for target &apos;modules/calib3d/CMakeFiles/opencv_calib3d.dir/all&apos; failedmingw32-make[1]: *** [modules/calib3d/CMakeFiles/opencv_calib3d.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 原因因为 OpenCV 在 chessboard.cpp、chessboard.hpp、test_chesscorners.cpp 这些代码中有 BUG，使用的应该是 CV_PI 而不是 M_PI 导致的。具体见我提的 Issue：Failed to compile opencv-4.0.0-alpha using mingw-w64 解决 在最新的 master 分支已经解决了这个问题，见我的 pull ：M_PI changed to CV_PI 如果你是在 官网 或者 github.com/opencv/opencv/releases 中下的 OpenCV 4.0.0-alpha，可能还会有这个问题，那么你需要把 chessboard.cpp、chessboard.hpp、test_chesscorners.cpp 文件中的 M_PI 全部改为 CV_PI，如我的 commit 所示：M_PI changed to CV_PI (#12645) 然后重新 Configure-Generate-mingw32-make 其他错误如果以上错误不是你所遇到的，请务必先看下面两个文章中的错误。 编译 32位 OpenCV 博文的常见错误 Tutorial: Installation from source for Windows with Mingw-w64]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下 CLion 编写调用 C++ 共享库]]></title>
    <url>%2F2018%2F07%2F20%2FWritingCppSharedLibraryOnLinuxCLion%2F</url>
    <content type="text"><![CDATA[编写 MySharedLib 共享库创建一个名为 MySharedLib 的共享库 CMakeLists.txt123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!void hello();// 使用可变模版参数求和template &lt;typename T&gt;T sum(T t)&#123;return t;&#125;template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest)&#123;return first + sum&lt;T&gt;(rest...);&#125;#endif library.cpp123456#include &lt;iostream&gt;#include "library.h"void hello() &#123;std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;&#125; 被 TestSharedLib 可执行项目调用创建一个名为 TestSharedLib 的可执行项目 CMakeLists.txt12345678910111213141516171819cmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译set(CMAKE_CXX_STANDARD 11)# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories($&#123;INC_DIR&#125;)link_directories($&#123;LIB_DIR&#125;)link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib) main.cpp12345678910111213#include &lt;iostream&gt;#include "library.h"using std::cout;using std::endl;int main() &#123;hello();cout &lt;&lt; "1 + 2 = " &lt;&lt; sum(1,2) &lt;&lt; endl;cout &lt;&lt; "1 + 2 + 3 = " &lt;&lt; sum(1,2,3) &lt;&lt; endl;return 0;&#125; 执行结果123Hello, World!1 + 2 = 31 + 2 + 3 = 6]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UWP 动画改变控件大小（高度）]]></title>
    <url>%2F2018%2F07%2F18%2FUWPAnimationChangesControlHeight%2F</url>
    <content type="text"><![CDATA[有这样一个需求： 鼠标移动到（悬停在）控件上（PointerEntered），控件大小（高度）发生变化，以显示更多内容； 鼠标移出控件（PointerExited），控件大小恢复原状。 本文通过 UWP 动画，用两种方法实现这个效果，用于改变周贡献榜和粉丝榜的 Grid 的高度。 方法一：XAML 实现动画XAML：1234567891011121314&lt;UserControl.Resources&gt; &lt;!--周贡、粉丝榜下拉恢复动画--&gt; &lt;Storyboard x:Name="SeeMoreAnimation" Storyboard.TargetName="WeekFansGrid"&gt; &lt;DoubleAnimation Duration="0:0:0.2" EnableDependentAnimation="True" Storyboard.TargetProperty="Height" From="140" To="400"/&gt; &lt;/Storyboard&gt; &lt;Storyboard x:Name="RestoreAnimation" Storyboard.TargetName="WeekFansGrid"&gt; &lt;DoubleAnimation Duration="0:0:0.2" EnableDependentAnimation="True" Storyboard.TargetProperty="Height" From="400" To="140"/&gt; &lt;/Storyboard&gt;&lt;/UserControl.Resources&gt;&lt;Grid x:Name="WeekFansGrid" Background="White" VerticalAlignment="Top" Height="140" PointerEntered="Grid_PointerEntered" PointerExited="Grid_PointerExited"&gt; &lt;!--Grid 里面的一些内容--&gt;&lt;/Grid&gt; C#：12345678910111213141516171819202122232425// 鼠标悬停周贡、粉丝榜的 Gridprivate void Grid_PointerEntered(object sender, PointerRoutedEventArgs e)&#123; try &#123; SeeMoreAnimation.Begin(); &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerEntered " + e1.Message.ToString()); &#125;&#125;// 鼠标离开周贡、粉丝榜的 Gridprivate void Grid_PointerExited(object sender, PointerRoutedEventArgs e)&#123; try &#123; RestoreAnimation.Begin(); &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerExited " + e1.Message.ToString()); &#125;&#125; 方法二：后台实现动画XAML：1234&lt;Grid x:Name="WeekFansGrid" Background="White" VerticalAlignment="Top" Height="140" PointerEntered="Grid_PointerEntered" PointerExited="Grid_PointerExited"&gt; &lt;!--Grid 里面的一些内容--&gt; &lt;/Grid&gt; C#：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 鼠标悬停周贡、粉丝榜的 Gridprivate void Grid_PointerEntered(object sender, PointerRoutedEventArgs e)&#123; try &#123; Grid grid = sender as Grid; if (grid != null) &#123; DoubleAnimation SeeMoreAnimation = new DoubleAnimation(); if (SeeMoreAnimation != null) &#123; // 高度从 140 变化到 400 SeeMoreAnimation.From = 140; SeeMoreAnimation.To = 400; // 用时 200 毫秒 SeeMoreAnimation.Duration = new Duration(TimeSpan.FromMilliseconds(200)); SeeMoreAnimation.EnableDependentAnimation = true; // 目标 Grid 的 Height Storyboard.SetTarget(SeeMoreAnimation, grid); Storyboard.SetTargetProperty(SeeMoreAnimation, "Height"); Storyboard storyboard = new Storyboard(); if (storyboard != null) &#123; storyboard.Children.Add(SeeMoreAnimation); // 执行动画 storyboard.Begin(); &#125; &#125; &#125; &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerEntered " + e1.Message.ToString()); &#125;&#125;// 鼠标离开周贡、粉丝榜的 Gridprivate void Grid_PointerExited(object sender, PointerRoutedEventArgs e)&#123; try &#123; Grid grid = sender as Grid; if (grid != null) &#123; DoubleAnimation SeeMoreAnimation = new DoubleAnimation(); if (SeeMoreAnimation != null) &#123; // 高度从 400 变化到 140 SeeMoreAnimation.From = 400; SeeMoreAnimation.To = 140; // 用时 200 毫秒 SeeMoreAnimation.Duration = new Duration(TimeSpan.FromMilliseconds(200)); SeeMoreAnimation.EnableDependentAnimation = true; // 目标 Grid 的 Height Storyboard.SetTarget(SeeMoreAnimation, grid); Storyboard.SetTargetProperty(SeeMoreAnimation, "Height"); Storyboard storyboard = new Storyboard(); if (storyboard != null) &#123; storyboard.Children.Add(SeeMoreAnimation); // 执行动画 storyboard.Begin(); &#125; &#125; &#125; &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerExited " + e1.Message.ToString()); &#125;&#125; 实现效果]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 生成带标签数据集的 CSV 文件]]></title>
    <url>%2F2018%2F06%2F17%2FUsingPythonToCreateCSV%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python# -*- coding: UTF-8 -*-# Python 生成 CSV 文件# Python 生成 CSV 文件，可用于生成带标签的数据集 CSV 文件，标签从0开始自动升序：0,1,2,3...# 作者：huihut# 仓库：https://gist.github.com/huihut/9881c98a1d9279d4fa9dfd8475e3fe4b# 参考：https://github.com/opencv/opencv_attic/blob/master/opencv/modules/contrib/doc/facerec/src/create_csv.py'''使用脚本：* python create_csv.py &lt;base_path&gt; [save_path]例如：* python create_csv.py /Users/xx/code/dataset* python create_csv.py /Users/xx/code/dataset ./dataset_csv.txt目录结构（使用 tree 命令查看）：xx@xxs-MacBook-Pro:~/code/dataset$ tree.├── README├── dataset_csv.txt├── s01│ ├── 01.pgm│ ├── ...│ └── 10.pgm├── s02│ ├── 01.pgm│ ├── ...│ └── 10.pgm...└── s10 ├── 01.pgm ├── ... └── 10.pgm生成的 CSV 文件内容（使用 cat 命令查看 dataset_csv.txt 文件内容）：xx@xxs-MacBook-Pro:~/code/dataset$ cat dataset_csv.txt/Users/xx/code/dataset/s01/01.pgm;0/Users/xx/code/dataset/s01/02.pgm;0.../Users/xx/code/dataset/s01/10.pgm;0/Users/xx/code/dataset/s02/01.pgm;1/Users/xx/code/dataset/s02/02.pgm;1.../Users/xx/code/dataset/s10/01.pgm;9/Users/xx/code/dataset/s10/02.pgm;9.../Users/xx/code/dataset/s10/10.pgm;9'''import sysimport os.pathif __name__ == "__main__": SAVE_PATH = "./dataset_csv.txt" if (len(sys.argv) != 2 and len(sys.argv) != 3): print "usage:" print "* python create_csv.py &lt;base_path&gt; [save_path]" print "example:" print "* python create_csv.py /Users/xx/code/dataset" print "* python create_csv.py /Users/xx/code/dataset ./dataset_csv.txt" sys.exit(1) elif (len(sys.argv) == 3): SAVE_PATH = sys.argv[2] BASE_PATH = sys.argv[1] SEPARATOR = ";" fh = open(SAVE_PATH,'w') label = 0 for dirname, dirnames, filenames in os.walk(BASE_PATH): for subdirname in dirnames: subject_path = os.path.join(dirname, subdirname) for filename in os.listdir(subject_path): abs_path = "%s/%s" % (subject_path, filename) print "%s%s%d" % (abs_path, SEPARATOR, label) fh.write(abs_path + SEPARATOR + str(label) + "\n") label = label + 1 fh.close()]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode 的 C/C++ 调试环境的 launch.json、 tasks.json 文件]]></title>
    <url>%2F2018%2F06%2F12%2FVSCodeCppLaunchTasks%2F</url>
    <content type="text"><![CDATA[launch.json12345678910111213141516171819202122232425262728293031323334353637// Configuring tasks.json for C/C++ debugging// author: huihut// repo: https://gist.github.com/huihut/9548fe7e1084cf8e844120c5668b8177// Available variables which can be used inside of strings.// $&#123;workspaceRoot&#125;: the root folder of the team // $&#123;file&#125;: the current opened file // $&#123;fileBasename&#125;: the current opened file's basename // $&#123;fileDirname&#125;: the current opened file's dirname // $&#123;fileExtname&#125;: the current opened file's extension // $&#123;cwd&#125;: the current working directory of the spawned process&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "preLaunchTask": "build", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125;]&#125; tasks.json123456789101112131415161718192021222324252627282930313233343536373839404142// Configuring tasks.json for C/C++ debugging // author: huihut// repo: https://gist.github.com/huihut/887d3c28db92617bd5148c20a5ff112a// Available variables which can be used inside of strings.// $&#123;workspaceRoot&#125;: the root folder of the team // $&#123;file&#125;: the current opened file // $&#123;fileBasename&#125;: the current opened file's basename // $&#123;fileDirname&#125;: the current opened file's dirname // $&#123;fileExtname&#125;: the current opened file's extension // $&#123;cwd&#125;: the current working directory of the spawned process&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build", "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", "focus": false, "panel": "shared" &#125;, "windows": &#123; "command": "g++", "args": [ "-ggdb", "\"$&#123;file&#125;\"", "--std=c++11", "-o", "\"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe\"" ] &#125; &#125; ]&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 调用 Python 模块]]></title>
    <url>%2F2018%2F06%2F12%2FCppCallPython%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546// C++ call Python module // author: huihut// repo: https://gist.github.com/huihut/b4597d097123a8c8388c71b3f0ff21e5#include &lt;iostream&gt;#include &lt;Python.h&gt;// C++ call Python modulebool CppCallPython()&#123; // Python initialize Py_Initialize(); if (!Py_IsInitialized()) &#123; std::cout &lt;&lt; "Python initialization failed!\n"; return false; &#125; // If my MyPython.py file is in "/Users/xx/code", set the working path to "/Users/xx/code" std::string path = "/Users/xx/code"; PySys_SetPath(&amp;path[0u]); // Import MyPython.py module PyObject* pModule = PyImport_ImportModule("MyPython"); if (!pModule) &#123; std::cout &lt;&lt;"Cannot open Python file!\n"; return false; &#125; // Get the HelloPython() function in the module PyObject* pFunhello = PyObject_GetAttrString(pModule, "HelloPython"); if (!pFunhello) &#123; std::cout &lt;&lt; "Failed to get this function!"; return false; &#125; // Call HelloPython() PyObject_CallFunction(pFunhello, NULL); // Finalize Py_Finalize(); return true;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 使用 Qt 生成带标签数据集的 CSV 文件]]></title>
    <url>%2F2018%2F06%2F12%2FUsingQtToCreateCSV%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// C++ 使用 Qt 生成 CSV 文件// 以下函数实现生成特定类型的 CSV 文件，可用于生成带标签的数据集 CSV 文件，标签为图片上一级的文件夹名字。// 作者：huihut// 仓库：https://gist.github.com/huihut/c9f43e276ef7652f0471725482a1e4f6/*目录结构（使用 tree 命令查看）：xx@xxs-MacBook-Pro:~/code/dataset$ tree.├── README├── dataset_csv.txt├── s01│ ├── 01.pgm│ ├── ...│ └── 10.pgm├── s02│ ├── 01.pgm│ ├── ...│ └── 10.pgm...└── s10 ├── 01.pgm ├── ... └── 10.pgm-----------------------------------------------------------生成的 CSV 文件内容（使用 cat 命令查看 dataset_csv.txt 文件内容）：xx@xxs-MacBook-Pro:~/code/dataset$ cat dataset_csv.txt/Users/xx/code/dataset/s01/01.pgm,s01/Users/xx/code/dataset/s01/02.pgm,s01.../Users/xx/code/dataset/s01/10.pgm,s01/Users/xx/code/dataset/s02/01.pgm,s02/Users/xx/code/dataset/s02/02.pgm,s02.../Users/xx/code/dataset/s10/01.pgm,s10/Users/xx/code/dataset/s10/02.pgm,s10.../Users/xx/code/dataset/s10/10.pgm,s10*/#include &lt;QDir&gt;#include &lt;QDebug&gt;#include &lt;QDirIterator&gt;bool CreateCSV()&#123; // 数据集的基础路径 QString datasetdir = "/Users/xx/code/dataset"; // 生成的 CSV 文件的名字 QString csvName = "dataset_csv.txt"; // 数据集路径与数据集名字的分隔符 char separator = ','; // 数据集路径、数据集名字 QString datasetPath, datasetName; // 文件迭代器：获取指定类型（以下是 pgm、png、jpg 三种类型）的数据集文件 QDirIterator it(datasetdir, QStringList() &lt;&lt; "*.pgm" &lt;&lt; "*.png" &lt;&lt; "*.jpg", QDir::Files, QDirIterator::Subdirectories); if(!it.hasNext()) &#123; qDebug() &lt;&lt; "当前路径下数据集为空！\n"; return false; &#125; // 创建及打开 CSV 文件 QFile file(datasetdir + QDir::toNativeSeparators("/") + csvName); if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) &#123; qDebug() &lt;&lt; "打开 CSV 文件失败！\n"; return false; &#125; // 文件写的文本流 QTextStream csv_ts(&amp;file); // 文件迭代器中有指定数据集文件则依次迭代 while (it.hasNext()) &#123; // 数据集路径 datasetPath = it.next(); // 数据集名字 datasetName = datasetPath.section(QDir::toNativeSeparators("/"), -2, -2); // 写入文本流 csv_ts &lt;&lt; datasetPath &lt;&lt; separator &lt;&lt; datasetName &lt;&lt; "\n"; &#125; // 关闭文本流 file.close(); return true;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt GDB 无法调试 MSVC 编译的程序而报错：file format not recognized]]></title>
    <url>%2F2018%2F06%2F02%2FQtNotInExecutableFormat%2F</url>
    <content type="text"><![CDATA[环境 Windows 10 x64 Visual Studio 2017 Qt 5.11 异常Qt Debug 时提示异常： 1qt not in executable format. file format not recognized 原因编译器（Compiler）使用了 64 位版本的 MSVC，调试器（Debugger）却使用了 32 位的 MinGW 的 GDB，从而 GDB 不能调试 64 位程序而报错。 解决 在 Qt 的 工具 - 选项 - 构建和运行 - Debuggers 选择 CDB（Debugging Tools for Windows）， 不能自动检测到则手动添加，如：C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\cdb.exe， 没有 cdb 则下载：Windows Driver Kit (WDK)（下载装好后重启 Qt 一般就可以自动检测到）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一加 3T ROM、内核、固件、Recovery、框架、软件（APP）总结]]></title>
    <url>%2F2018%2F05%2F11%2Fawesome-oneplus-3t%2F</url>
    <content type="text"><![CDATA[一加 3T ROM、内核（Kernel）、固件（Firmware）、Recovery、框架（Framework）、软件（APP），以备茶余饭后手贱刷机之用。 相关链接 Github Repository： huihut/awesome-oneplus-3t 之前的相关博文：一加3T的刷机流程及玩机一些事 ROM基于 Android 8.1 NitrogenOS | 下载 Omni 8.1 | 下载 [Official] ResurrectionRemix v6.0.0 | 下载 AOSP Extended 5.4 | 下载 LineageOS 15.1 | 下载 Havoc-OS | 下载 Validus 2.2 | 下载 AICP 13.1 | 下载 AOSiP | 下载 GZOSP 1.0 | 下载 Candy 8.1 | 下载 A.O.S.C.P : CypherOS | 官方下载 | 非官方下载 MSM Xtended | 下载 Cosmic-OS 3.1 | 下载 [Unoffical] Resurrection Remix (LuisROM) | 下载 AOKP Oreo | 下载 NLOS-15.1 beta | 下载 Tugapower | 下载 MoKee Open Source Project | 下载 crDroid | 下载 BootleggersROM | 下载 AquariOS | 下载 CarbonROM | 下载 [Unofficial] ResurrectionRemix v6.0.0 | 下载 Pixel Experience | 下载 基于 Android 8.0 [一加官方] OnePlus 3T 氧OS(OxygenOS) 5.0.1 | 下载 [一加官方] OnePlus 3T 氧OS(OxygenOS) beta 26 | 下载 [一加官方] OnePlus 3T 氢OS(H2OS) 稳定版第7版 | 下载 [一加官方] OnePlus 3T 氢OS(H2OS) 公测版第11版 | 下载 ExperienceOS (OP3 only) [OOS 5.0.1 + OB35 Based] | 下载 theOne3TOS - [OOS 5.0.1 + OB26 Based] | OOS 下载 | Open Based 下载 其他 ROM OnePlus 3T ROMs 救砖工具包（基于 Android 6.0） 一加3T (A3010/全网通) 官方恢复兼救砖 （安卓6.0） | 下载地址一 | 下载地址二 内核 Kernel Caesium - CadaverousCherry | 下载 Derp 4.0 (OOS) | 下载 Flash | 下载(OOS) | 下载(Custom) Boeffla kernel 3.0 beta 5 (OOS) | OP3T 下载 | OP3 下载 Boeffla kernel 3.0 beta 5 (LOS 15.1) | OP3T 下载 | OP3 下载 White Wolf (OOS) | OP3T 下载 White Wolf (Custom) | OP3T 下载 HolyDragon | 下载 (OOS/H2OS) | 下载 (Omni/AOSP) MadysXtended [Android 8.1 Only] | Franco Kernel | 下载 (OOS) OP3T OP3 | 下载 (Custom) OP3T OP3 固件 Firmware OP3T | [OP3T][FIRMWARE+MODEM] Open Beta 26 - Oreo | 下载 (OOS) | 下载 (Open Beta) OP3 | [FIRMWARE/MODEM] Collection - Flashable Zips! | 下载 (OOS) | 下载 (Open Beta) Recovery [一加官方] Oxygen Recovery Official TWRP 3.2.1-0 (unified) | 下载 ADB下载Windows 版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-windows.zip 网盘下载链接：http://pan.baidu.com/s/1eRG8gXs 密码：72ac MacOS 版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-darwin.zip 网盘下载链接：http://pan.baidu.com/s/1pLQFvrt 密码：7qav Linux 版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-linux.zip 网盘下载链接：http://pan.baidu.com/s/1nu8mvrF 密码：giug 教程 How to Install ADB on Windows, macOS, and Linux 框架 FrameworkXposed下载 [zip] Xposed for Oreo | SDK26 Android 8.0 下载 | SDK27 Android 8.1 下载 [zip] Xposed Uninstaller [apk] Xposed Installer [apk] Material Design Xposed Installer | 下载 模块 Android 系统上的 Xposed 框架中都有哪些值得推荐的模块？ Magisk下载 [zip] Latest Magisk [zip] Latest Uninstaller (Support all versions) [apk] Latest Magisk Manager 模块 [教程] (搬运XDA)magisk框架教程以及模块-xposed的替代品 软件 APP应用市场 Google Play 酷安 Shadowsocks Github . shadowsocks/shadowsocks-android Google Play . Shadowsocks ShadowsocksR Github . shadowsocksr-backup/shadowsocksr-android GAPPS Open Gapps (8.0/8.1) Pixel2Mod Google Camera Pixel2Mod Google Camera Google Pixel 实时动态壁纸 [Google Pixel/2] Live Wallpapers 绿色守护 Google Play . 绿色守护 (Greenify) 酷安 . Greenify绿色守护 教程How to grant permissions required by some features on non-root device? 命令Android 7.0+ 非 root 开启嗜睡模式授权命令（其他命令见教程）： 1adb -d shell pm grant com.oasisfeng.greenify android.permission.WRITE_SECURE_SETTINGS 冰箱 Google Play . 冰箱 Ice Box —自动冻结应用 酷安 . 冰箱 Ice Box 教程冰箱免 Root（设备管理员模式）使用配置方法 命令1adb shell dpm set-device-owner com.catchingnow.icebox/.receiver.DPMReceiver 黑域 Google Play . 黑阈 酷安 . 黑阈 命令1adb -d shell sh /data/data/me.piebridge.brevent/brevent.sh 教程博文 [INFO] List of all Oreo roms/kernels/recovery for 3/3T (UPDATED : 2018-05-06) [GUIDE] OnePlus 3T: How to Unlock Bootloader | Flash TWRP | Root | Nandroid &amp; EFS Backup and More !!]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter beta 版尝鲜（在 Windows + Android Studio 与 MacOS + VS Code 的安装配置）]]></title>
    <url>%2F2018%2F03%2F13%2FFlutterBetaTaste%2F</url>
    <content type="text"><![CDATA[Flutter 是一个 Google 发布的跨平台移动 UI 框架，使用 Dart 语言开发，可以构建高质量原生 iOS 、Android 以及 Fuchsia OS 应用，并且在排版、图标、滚动、点击等方面实现零差异。 Flutter 官网 鉴于最近出了 beta 版，就来尝鲜一下吧。 本文有 Windows + Android Studio 与 MacOS + VS Code 的体验。 Windows + Android Studio获取 Flutter SDK使用 git 克隆下来 Flutter SDK 1git clone -b beta https://github.com/flutter/flutter.git 也可以使用中国的镜像，使用方法：Using Flutter in China 配置环境变量添加 flutter\bin 的完整路径到用户变量 Path，如： 1D:\code\git\flutter\bin 安装依赖打开cmd或者PowerShell，安装 1flutter doctor 安装过程可能持续比较久 为 Android Studio 安装 Flutter 插件 装好后重启 Android Studio 创建 Flutter APP 选择 File &gt; New Flutter Project 选择 Flutter application 输入应用名 flutter_app，输入 Flutter SDK 路径（如我的：D:\code\git\flutter） Finish 等待创建 创建好后，应用程序的代码在lib/main.dart 启动 Flutter APP 选择设备 Run 尝试热重载把lib/main.dart里面的字符串 &#39;You have pushed the button this many times:&#39; 改成 &#39;Hahaha, You have clicked the button this many times:&#39; 不用停止模拟器，直接 Save All（cmd-s/ ctrl-s），或者单击 Hot Reload 按钮（带有闪电图标的按钮） 就能看到模拟器中间那行字符串很快更新了。 嗯，体验还是蛮爽的！ MacOS + VS Code接下来看下在 MacOS 下的安装 获取 Flutter SDK12git clone -b beta https://github.com/flutter/flutter.gitexport PATH=`pwd`/flutter/bin:$PATH 配置环境变量打开环境变量配置文件 1sudo vi $HOME/.bash_profile 添加一行你的flutter/bin的绝对路径，如我的： 1export PATH=/Users/xx/code/git/flutter/bin:$PATH 刷新 1source $HOME/.bash_profile 验证一下是否配置好 1echo $PATH 安装依赖1flutter doctor 为 VS Code 安装 Flutter 插件在扩展商店中搜索 Dart Code 下载安装 安装好后重新打开 点击 查看 - 命令面板，搜索 Flutter: Run Flutter Doctor 如果 VS Code 找不到 Flutter SDK 路径，就点击进行配置 配置好后重新 Flutter: Run Flutter Doctor，检查配置是否成功 编译 iOS 需要 Xcode 9.0.0+接下来再检查还需要安装什么 1flutter doctor 然后突然发现。。。 要编译 iOS 应用需要 Xcode 9.0.0+ ！ 可是官网明明说的是 Xcode 7.2+ ？打脸？？ 对此，我特意把我的 Xcode 从 7.1 更新到 7.2，结果还是说需要 9.0.0+，看来是官网教程没更新了。 什么？你说为什么不更新到 Xcode 最新版？ 这个……由于博主的是黑苹果，无法升级 MacOS，现在还是 OSX 10.10.5，最高支持的 Xcode 是 7.2.1 所以只好再编译 Android 应用了，下面也只讲构建 Android 的 这里附上有编译 iOS 的教程：Flutter基础—开发环境与入门 创建并执行 Flutter APP在 VS Code 的终端（或其他终端）上跳转到要创建项目的路径，然后创建名为flutter_app的项目 1234cd ~/code/Androidflutter create flutter_appcd flutter_appflutter run 在 Windows 的时候使用的是模拟器，现在用真机体验一下 运行后，试着修改字符串 &#39;You have pushed the button this many times:&#39; 改成 &#39;yeah, You have pushed the button this many times:&#39; 保存，然后在终端按 r 热重载 r：热重载 R：重启整个APP h：帮助 q：退出APP 嗯，Cool。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 弃用 TLS 1.0、1.1 导致 push 异常 SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version]]></title>
    <url>%2F2018%2F02%2F28%2FGitHubAbandonedTLS1.0_1.1%2F</url>
    <content type="text"><![CDATA[报错git push 到 Github 的时候出现异常： 12fatal: unable to access &apos;https://github.com/huihut/interview.git/&apos;: error:1407742E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol versionPushing to https://github.com/huihut/interview.git 原因在 2018年2月22日19:00 UTC（太平洋标准时间上午11:00），GitHub 停止了对加密弱 TLS 1.0 和 1.1 协议的支持，并且仅支持与 TLS 1.2 协议的连接。 官方声明： Github . Weak cryptographic standards removal notice 因此，如果你的 git 连接方式仍然是 TLS 1.0 或 1.1，则会报错。 解决① 查看你的 TLS 版本 1git config --global --list ② 如果仍然是 TLS 1.0 或 1.1，则下载更新 Git 最新版：https://git-scm.com/ ③ 安装好最新版 Git 后，更新 TLS 12git config --global --unset http.sslVersiongit config --global --add http.sslVersion tlsv1.2 ④ 现在则可以使用 TLS 1.2 传输，并解决了此问题 操作如下图：]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个可以模仿你的表情的语音聊天机器人 —— Facemoji 废萌（OpenCV+Dlib+Live2D+图灵机器人+讯飞IAT语音听写+讯飞TTS语音合成）]]></title>
    <url>%2F2018%2F02%2F08%2FFacemoji1%2F</url>
    <content type="text"><![CDATA[概述本文介绍一个可以模仿你的表情的语音聊天机器人 —— Facemoji 废萌 这是个 Unity 项目，其暂时有两个模块 ： 【模块一】是实时人脸卡通化（FaceTracking），使用 OpenCV 和 Dlib 检测面部表情，并实时转化为 Live2D 模型，然后可 录制 成 gif 图； 【模块二】是人工智能（AI）使用 图灵机器人、讯飞IAT语音听写、讯飞TTS语音合成 进行语音聊天。 预览 源码源码：Github . huihut/Facemoji 下载 酷安 . Facemoji 废萌 Google Play (需要梯子) Github . Facemoji/releases Google云盘 . Facemoji/Platform Baidu网盘 . Facemoji/Platform 为什么叫废萌（Facemoji）首先，为什么叫废萌（Facemoji）？…emmm…这个项目其实是由 Animoji 启发的，由于当时 Animoji 没有开放 api，所以想开发个跨平台（Unity）的类似的项目，就叫 Facemoji。 至于中文名废萌嘛？…emmm…总觉得她除了卖萌没什么作用，所以就叫废（Face）萌（Moji）了。 制作 从 Google云盘 或者 Baidu网盘下载shape_predictor_68_face_landmarks.dat（已训练好的人脸检测模型）和 Facemoji_Plugins_Assets_1.5.0.unitypackage（精简的 OpenCV, Dlib, Live2D 和 Iflytek 库） 克隆下源码：git clone git@github.com:huihut/Facemoji.git 创建一个新的 Unity 项目，命名为 Facemoji 把 Facemoji-master 文件夹中的 Assets 和 ProjectSettings 替换 Facemoji 的同名文件夹 把 shape_predictor_68_face_landmarks.dat 复制到 Facemoji/Assets/StreamingAssets/ 导入 Facemoji_Plugins_Assets_1.5.0.unitypackage。导入后的文件结构如下： 转换平台到 Android（其他平台未适配） Build &amp; Run 使用实时人脸卡通化（FaceTracking）使用 OpenCV 和 Dlib 检测面部表情，并实时转化为 Live2D 模型； 她可以跟着你的头部表情动，试着摇头看看吧。 录制 gif 图点击顶部中间的录制键可以录制 3 秒的 gif； 录制状态为：Recording（准备录制）、PreProcessing（正在录制）、Paused（正在压缩成gif图） 生成的 gif 存储在 Application.dataPath，Android 平台的话在/storage/emulated/0/Android/data/com.huihut.facemoji/files/ 语音和文字聊天（聊天机器人？ 她说她是 AI，不是机器人！ hhhh…）使用 图灵机器人、讯飞 IAT 语音听写、讯飞 TTS 语音合成 她很智能（zhizhang），可以： 聊天对话 生活百科 数学计算 故事大全 笑话大全 成语接龙 星座运势 天气查询 … 但是由于她是个中国 AI（机器人），图灵机器人只支持中文，所以她只能进行中文聊天，和她讲英文她只会翻译。 不过她以后会学习英文的（换个会讲英文的）。 Gif演示 异常问题人不动时模型抖动问题（特别是眼睛眉毛）Facemoji/issues/1原因 手/眼/眉等的轻微抖动 Dlib 检测到的每一帧人脸特征点的位置会有轻微差距 解决 调整模型参数 如果人眼睛小的话，可以修改 FaceTracking.cs 中 live2DModelUpdate 方法，把睁开眼的区间改大一点，如下： 123456789// eye_open_L // 左眼float eyeOpen_L = getRaitoOfEyeOpen_L (points);if (eyeOpen_L &gt; 0.4f &amp;&amp; eyeOpen_L &lt; 1.0f) eyeOpen_L = 1; // 睁开眼else if (eyeOpen_L &gt;= 1.0f) eyeOpen_L = 2; // 睁大眼else if (eyeOpen_L &lt;= 0.4f) eyeOpen_L = 0; // 闭上眼live2DModel.PARAM_EYE_L_OPEN = eyeOpen_L; 考虑使用卡尔曼滤波器或者其他滤波器过滤（未尝试） 修改说明 2018年03月23日因项目更新 v1.5.0 版本而对此博文做了修改。因博文内容不常改动，项目部署、文档等以Github为准。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt的QVaiant中使用非QMetaType类型缺少Q_DECLARE_METATYPE宏定义错误]]></title>
    <url>%2F2017%2F12%2F05%2FQVaiantQ_DECLARE_METATYPE%2F</url>
    <content type="text"><![CDATA[报错123E:\Qt\Qt5.9.3\5.9.3\mingw53_32\include\QtCore\qglobal.h:738: error: static assertion failed: Type is not registered, please use the Q_DECLARE_METATYPE macro to make it known to Qt&apos;s meta-object system #define Q_STATIC_ASSERT_X(Condition, Message) static_assert(bool(Condition), Message) ^ 报错代码123const QCameraInfo &amp;cameraInfo...QVariant::fromValue(cameraInfo) 原因QVaiant 不能识别自定义类型和其他非 QMetaType 内置类型， 而 QCameraInfo 是非 QMetaType 内置类型，因此使用 QVariant::fromValue(cameraInfo) 之前，需要使用 Q_DECLARE_METATYPE 宏对 QCameraInfo 进行声明。 解决在代码中加个宏定义： 1Q_DECLARE_METATYPE(QCameraInfo) 总结 Q_DECLARE_METATYPE 如果要使自定义类型或其他非 QMetaType 内置类型在 QVaiant 中使用，必须使用该宏 该类型必须有公有的 构造、析构、复制构造 函数 qRegisterMetaType 必须使用该函数的两种情况 如果非 QMetaType 内置类型要在 Qt 的属性系统中使用 如果非 QMetaType 内置类型要在 queued 信号与槽 中使用 参考 Q_DECLARE_METATYPE与qRegisterMetaType学习 How to use QVariant::fromValue with QString? QMetaType Class - Q_DECLARE_METATYPE(Type)]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV使用CMake和MinGW的编译安装及其在Qt配置运行]]></title>
    <url>%2F2017%2F12%2F03%2FCompiledOpenCVRunInQt%2F</url>
    <content type="text"><![CDATA[前言本篇博文是使用 32 位的 MinGW 在 Windows 下编译 OpenCV 生成 32 位的 dll。 关于使用 64 位的 MinGW 编译 OpenCV 生成 64 位的 dll，见：OpenCV使用CMake和MinGW-w64的编译安装 编译好的 OpenCV（MinGW 版）：Github . huihut/OpenCV-MinGW-Build 软件环境 Windows-10-64bit Qt-5.9.3 MinGW-5.3.0-32bit CMake-3.9.2 OpenCV-3.3.1 / 3.4.1(适用) OpenCV 的 MSVC 版及 MinGW 版MSVC 版下载的 OpenCV 文件夹会有： build （已编译好的库） sources （源码） 使用 MSVC 的话，直接在 1build/x64/vc14 里面就有了，配置好路径就可以使用。 MinGW 版OpenCV 没有为我们编译好 MinGW 版，所以我们只能自己编译，下面就是介绍 MinGW 版的编译流程。 也可以直接下载使用我编译好了的 OpenCV （在上文）。 安装及配置 Qt、MinGW、CMake安装CMake 自行安装，Qt 和 MinGW 可以直接使用qt-opensource-windows-x86-5.9.3.exe 安装包安装，注意选择安装的组件(components)的时候勾选 MinGW : Qt-Qt5.9-MingGW 5.3.0 32 bit Qt-Tools-MinGW 5.3.0 配置 Qt、MinGW安装好后打开QtCreator，在工具-选项-构建和运行-构建套件，选中Desktop Qt 5.9.3 MinGW 32bit，设为默认，OK。 添加 MinGW 到环境变量为系统变量 Path 添加 E:\Qt\Qt5.9.3\Tools\mingw530_32\bin 使用 CMake 生成 OpenCV 的 Makefile打开 cmake-gui，设置源码和生成路径： Where is the source code: E:/OpenCV_3.3.1/opencv/sources Where to build the binaries: E:/OpenCV_3.3.1/opencv-build 点击 Configure，设置编译器 Specify the generator for this project: MinGW Makefiles Specify native compilers Next Compilers C: E:\Qt\Qt5.9.3\Tools\mingw530_32\bin\gcc.exe Compilers C++: E:\Qt\Qt5.9.3\Tools\mingw530_32\bin\g++.exe Finish 编译配置： 勾选 WITH_QT 勾选 WITH_OPENGL 点击 Configure，再次配置： 不勾选 WITH_IPP 设置 QT_MAKE_EXECUTABLE 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\bin\qmake.exe 设置 Qt5Concurrent_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Concurrent 设置 Qt5Core_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Core 设置 Qt5Gui_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Gui 设置 Qt5Test_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Test 设置 Qt5Widgets_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Widgets 设置 Qt5OpenGL_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5OpenGL 设置 CMAKE_BUILD_TYPE 为 Release 或者 RelWithDebInfo 点击 Generate 生成 Makefile 编译 OpenCV打开终端进行编译：（-j 是使用 8 个线程进行编译，请根据你的计算机配置合理设置线程数） 1234E:cd E:\OpenCV_3.3.1\opencv-buildmingw32-make -j 8mingw32-make install 如果 mingw32-make -j 8 遇到错误，请看下面的 编译 OpenCV 常见错误，否则执行 mingw32-make install，完成安装。 编译 OpenCV 常见错误0. 多线程编译错误信息不明确表现如果使用了多线程编译，导致错误，但是错误信息不明确，如： 12Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决使用单线程编译： 1mingw32-make 以查看详细的错误提示，再根据具体情况解决。 1. RC 错误表现1... windres.exe: unknown option -- W ... 或者 123FORMAT is one of rc, res, or coff, and is deduced from the file nameextension if not specified. A single file name is an input file.No input-file is stdin, default rc. No output-file is stdout, default rc. 解决在 cmake-gui 编译配置中： 不勾选 ENABLE_PRECOMPILED_HEADERS 然后重新Configure-Generate-mingw32-make 2. sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA 错误表现12...opencv/sources/modules/videoio/src/cap_dshow.cpp...... &apos;sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA&apos; was not declared in this scope ... 或者 12Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决修改E:\OpenCV_3.3.1\opencv\sources\modules\videoio\src\cap_dshow.cpp文件，在#include &quot;DShow.h&quot;这行的上面加一行#define NO_DSHOW_STRSAFE，如： 12#define NO_DSHOW_STRSAFE#include &quot;DShow.h&quot; 然后重新Configure-Generate-mingw32-make 3. identifier ‘nullptr’ is a keyword in C++11 错误【2018年3月2日编译OpenCV 3.4.1时遇到并解决】表现12345678910111213D:\opencv-3.4.1\opencv-3.4.1\3rdparty\protobuf\src\google\protobuf\stubs\io_win32.cc:94:3: warning: identifier &apos;nullptr&apos; is a keyword in C++11 [-Wc++0x-compat] return s == nullptr || *s == 0; ^D:\opencv-3.4.1\opencv-3.4.1\3rdparty\protobuf\src\google\protobuf\stubs\io_win32.cc: In function &apos;bool google::protobuf::internal::win32::&#123;anonymous&#125;::null_or_empty(const char_type*)&apos;:D:\opencv-3.4.1\opencv-3.4.1\3rdparty\protobuf\src\google\protobuf\stubs\io_win32.cc:94:15: error: &apos;nullptr&apos; was not declared in this scope return s == nullptr || *s == 0; ^3rdparty\protobuf\CMakeFiles\libprotobuf.dir\build.make:412: recipe for target &apos;3rdparty/protobuf/CMakeFiles/libprotobuf.dir/src/google/protobuf/stubs/io_win32.cc.obj&apos; failedmingw32-make[2]: *** [3rdparty/protobuf/CMakeFiles/libprotobuf.dir/src/google/protobuf/stubs/io_win32.cc.obj] Error 1CMakeFiles\Makefile2:710: recipe for target &apos;3rdparty/protobuf/CMakeFiles/libprotobuf.dir/all&apos; failedmingw32-make[1]: *** [3rdparty/protobuf/CMakeFiles/libprotobuf.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决在 cmake-gui 编译配置中： 勾选 ENABLE_CXX11 然后重新Configure-Generate-mingw32-make 添加 OpenCV 编译的库到环境变量 为系统变量 Path 添加 E:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin 新建 OpenCV 的 Qt 项目在 .pro 文件里面添加： 1234win32 &#123;INCLUDEPATH += E:\OpenCV_3.3.1\opencv-build\install\includeLIBS += E:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin\libopencv_*.dll&#125; 或者：（区分 debug 和 release 是因为 OpenCV 对其两者有不同的库，你需要把路径改为你自己的，我编译 MinGW 的 OpenCV 只有 release 库） 1234567891011121314win32 &#123;INCLUDEPATH += E:\OpenCV_3.3.1\opencv-build\install\includeCONFIG(debug, debug|release): &#123;LIBS += E:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin\libopencv_*d.dll&#125; else:CONFIG(release, debug|release): &#123;LIBS += -LE:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin \ -llibopencv_core331 \ -llibopencv_highgui331 \ -llibopencv_imgcodecs331 \ -llibopencv_imgproc331 \ -llibopencv_features2d331 \ -llibopencv_calib3d331&#125;&#125; 然后在 MainWindow 中如下： 123456789101112131415161718192021222324#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); // read an image cv::Mat image = cv::imread(&quot;E:/Pictures/H_white.png&quot;, 1); // create image window named &quot;My Image&quot; cv::namedWindow(&quot;My Image&quot;); // show the image on window cv::imshow(&quot;My Image&quot;, image);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 最后运行起来了，效果如图： 官方教程 How to setup Qt and openCV on Windows]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MFC的CDC类绘制三维坐标系及球面函数]]></title>
    <url>%2F2017%2F10%2F13%2FGraphicsExercise3D%2F</url>
    <content type="text"><![CDATA[系列链接 使用MFC的CDC类绘制二维坐标系及正余弦函数 / 源码 使用MFC的CDC类绘制三维坐标系及球面函数 / 源码 概述本文使用MFC的CDC类绘制三维坐标系及球面函数。首先计算推导出三维坐标在二维平面显示的坐标变换方程（使用斜二测视图），使用球面的参数方程，然后定义图形缩放比例规模、坐标轴位移，变换坐标系和规模等，最后绘制坐标轴及球面函数。 如果对绘制二维坐标系还不太熟悉可以先看上面系列链接的：使用MFC的CDC类绘制二维坐标系及正余弦函数，本文对二维绘制及绘制函数部分不再赘述。因为二维坐标系的博文已经分模块讲解地比较清楚了，而与三维坐标系的基本思路相同，所以本文大部分直接使用注释讲解。 三维转二维的推导 上图可知，只要使用Transform3Dto2D()函数，即可方便的把三维坐标转化为二维坐标（斜二测视图）。 球面参数方程在三维空间直角坐标系中，以原点为球心、半径为 r 的球面的方程为 x^2 + y^2 + z^2 = r^2，其参数方程为 新建项目Visual Studio- 新建项目 - MFC应用程序 - 命名为GraphicsExercise3D - 确定 - 下一步 - 应用程序类型选择单个文档 - 完成 GraphicsExercise3DView.h在GraphicsExercise3DView.h添加以下内容 1234567891011121314151617// 操作public: void SetScale(int scale); void SetTransformOrigin(float transformOriginX, float transformOriginY); void SetPlotSphere(float radius, float stepPhi, float stepTheta); void SetSlantRadian(float slant); float TransformScale(float num); float TransformOriginX(float x); float TransformOriginY(float y); float TransformOriginScaleX(float x); float TransformOriginScaleY(float y); void Transform3Dto2D(float &amp;x, float &amp;y, float z);private: int scale; float radius, stepPhi, stepTheta, slant, transformOriginX, transformOriginY; GraphicsExercise3DView.cpp引入数学函数库1#include &lt;math.h&gt; 定义π123#ifndef PI#define PI 3.14159#endif // !PI 在构造函数初始化 12345678910111213141516CGraphicsExercise3DView::CGraphicsExercise3DView()&#123; // TODO: 在此处添加构造代码 // 设置斜二测视图倾斜角度（弧度制） SetSlantRadian(PI / 4); // 设置规模比例 SetScale(70); // 设置坐标系在x、y方向的位移（不改变规模情况下，即移动像素） SetTransformOrigin(300, 350); // 设置球面半径radius、取样步长stepPhi、stepTheta SetPlotSphere(2.0, 0.01, 0.1);&#125; 设置初始化参数的Set函数 1234567891011121314151617181920212223242526// 设置规模void CGraphicsExercise3DView::SetScale(int scale)&#123; this-&gt;scale = scale;&#125;// 设置坐标系原点在x、y方向的位移（不改变规模情况下，即移动像素）void CGraphicsExercise3DView::SetTransformOrigin(float transformOriginX, float transformOriginY)&#123; this-&gt;transformOriginX = transformOriginX; this-&gt;transformOriginY = transformOriginY;&#125;// 设置球面半径radius、取样步长stepPhi、stepThetavoid CGraphicsExercise3DView::SetPlotSphere(float radius, float stepPhi, float stepTheta)&#123; this-&gt;radius = radius; this-&gt;stepPhi = stepPhi; this-&gt;stepTheta = stepTheta;&#125;// 设置斜二测视图的倾斜角（单位弧度）void CGraphicsExercise3DView::SetSlantRadian(float slant)&#123; this-&gt;slant = slant;&#125; 坐标及规模变换 1234567891011121314151617181920212223242526272829// 变换规模float CGraphicsExercise3DView::TransformScale(float num)&#123; return num * scale;&#125;// 坐标系X轴方向位移float CGraphicsExercise3DView::TransformOriginX(float x)&#123; return x + transformOriginX / scale;&#125;// 坐标系y轴方向位移float CGraphicsExercise3DView::TransformOriginY(float y)&#123; return y - transformOriginY / scale;&#125;// 变换坐标系X和规模float CGraphicsExercise3DView::TransformOriginScaleX(float x)&#123; return TransformScale(TransformOriginX(x));&#125;// 变换坐标系Y和规模float CGraphicsExercise3DView::TransformOriginScaleY(float y)&#123; return -TransformScale(TransformOriginY(y));&#125; 三维坐标转化为二维坐标 123456// 使用斜二测视图，把三维坐标点转化为二维平面上的点void CGraphicsExercise3DView::Transform3Dto2D(float &amp;x, float &amp;y, float z)&#123; x = x - (z * cos(slant)) / 2; y = y - (z * sin(slant)) / 2;&#125; 绘制坐标轴及函数图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// CGraphicsExercise2View 绘制void CGraphicsExercise3DView::OnDraw(CDC* pDC)&#123; CGraphicsExercise3DDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 float x, y, z; // -------------------- 绘制坐标系 ------------------------- // 坐标x轴 pDC-&gt;MoveTo(TransformOriginScaleX(0), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(radius + 2), TransformOriginScaleY(0)); // 坐标y轴 pDC-&gt;MoveTo(TransformOriginScaleX(0), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(0), TransformOriginScaleY(radius + 2)); // 坐标z轴 x = 0, y = 0; Transform3Dto2D(x, y, radius + 5); pDC-&gt;MoveTo(TransformOriginScaleX(0), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); // 坐标x轴的箭头 pDC-&gt;MoveTo(TransformOriginScaleX(radius + 1.8), TransformOriginScaleY(0.2)); pDC-&gt;LineTo(TransformOriginScaleX(radius + 2), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(radius + 1.8), TransformOriginScaleY(-0.2)); // 坐标y轴的箭头 pDC-&gt;MoveTo(TransformOriginScaleX(-0.2), TransformOriginScaleY(radius + 1.8)); pDC-&gt;LineTo(TransformOriginScaleX(0), TransformOriginScaleY(radius + 2)); pDC-&gt;LineTo(TransformOriginScaleX(0.2), TransformOriginScaleY(radius + 1.8)); // 坐标z轴的箭头 x = 0, y = 0.2; Transform3Dto2D(x, y, radius + 5 - 0.2); pDC-&gt;MoveTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); x = 0, y = 0; Transform3Dto2D(x, y, radius + 5); pDC-&gt;LineTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); x = 0.2, y = 0; Transform3Dto2D(x, y, radius + 5 - 0.2); pDC-&gt;LineTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); // -------------------- 绘制刻度线 ------------------------- // 绘制x轴刻度线 for (float scaleX = 0.2; scaleX &lt; radius + 1; scaleX += 0.2) &#123; pDC-&gt;MoveTo((int)TransformOriginScaleX(scaleX), (int)TransformOriginScaleY(0)); pDC-&gt;LineTo((int)TransformOriginScaleX(scaleX), (int)TransformOriginScaleY(0.1)); &#125; // 绘制y轴刻度线 for (float scaleY = 0.2; scaleY &lt;= radius + 1; scaleY += 0.2) &#123; pDC-&gt;MoveTo((int)TransformOriginScaleX(0), (int)TransformOriginScaleY(scaleY)); pDC-&gt;LineTo((int)TransformOriginScaleX(0.1), (int)TransformOriginScaleY(scaleY)); &#125; // 绘制z轴刻度线 for (float x = 0, y = 0, scaleZ = 0.2; scaleZ &lt;= radius + 4; scaleZ += 0.2, x = 0, y = 0) &#123; Transform3Dto2D(x, y, scaleZ); pDC-&gt;MoveTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); pDC-&gt;LineTo((int)TransformOriginScaleX(x + 0.1), (int)TransformOriginScaleY(y)); &#125; // -------------------- 绘制文字 ------------------------- // 绘制x轴的x pDC-&gt;TextOutW(TransformOriginScaleX(radius + 1.6), TransformOriginScaleY(-0.2), CString(&quot;x&quot;)); // 绘制y轴的y pDC-&gt;TextOutW(TransformOriginScaleX(-0.2), TransformOriginScaleY(radius + 1.6), CString(&quot;y&quot;)); // 绘制z轴的z x = 0.2, y = 0; Transform3Dto2D(x, y, radius + 5 - 0.4); pDC-&gt;TextOutW(TransformOriginScaleX(x), TransformOriginScaleY(y), CString(&quot;z&quot;)); CString s; // 绘制x轴刻度文字 for (float ScaleTextX = 0.4; ScaleTextX &lt; radius + 1; ScaleTextX += 0.4) &#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextX); pDC-&gt;TextOutW(TransformOriginScaleX(ScaleTextX - 0.1), TransformOriginScaleY(-0.1), s); &#125; // 绘制y轴刻度文字 for (float ScaleTextY = 0.4; ScaleTextY &lt;= radius + 1; ScaleTextY += 0.4) &#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextY); pDC-&gt;TextOutW(TransformOriginScaleX(-0.4), TransformOriginScaleY(ScaleTextY + 0.1), s); &#125; // 绘制z轴刻度文字 for (float ScaleTextZ = 0.6; ScaleTextZ &lt;= radius + 4; ScaleTextZ += 0.6) &#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextZ); x = 0, y = 0; Transform3Dto2D(x, y, ScaleTextZ); pDC-&gt;TextOutW(TransformOriginScaleX(x + 0.15), TransformOriginScaleY(y + 0.12), s); &#125; // 绘制函数图的Title x = 0, y = 0; Transform3Dto2D(x, y, radius + 5); pDC-&gt;TextOutW(TransformOriginScaleX(x + 3), TransformOriginScaleY(y), CString(&quot;x^2 + y^2 + z^2 = r^2&quot;)); // -------------------- 绘制函数 ------------------------- // 球面 float phi, theta; for (phi = 0; phi &lt; 2 * PI; phi += stepPhi) &#123; for (theta = 0; theta &lt; PI; theta += stepTheta) &#123; x = radius * sin(phi) * cos(theta); y = radius * sin(phi) * sin(theta); z = radius * cos(phi); Transform3Dto2D(x, y, z); srand(z); pDC-&gt;SetPixel(TransformOriginScaleX(x), TransformOriginScaleY(y), RGB(rand() % 255, rand() % 255, rand() % 255)); &#125; &#125; //// 三棱锥（测试用） //x = 1, y = 0, z = 0; //Transform3Dto2D(x, y, z); //pDC-&gt;MoveTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); //x = 0, y = 1, z = 0; //Transform3Dto2D(x, y, z); //pDC-&gt;LineTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); //x = 0, y = 0, z = 1; //Transform3Dto2D(x, y, z); //pDC-&gt;LineTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); //x = 1, y = 0, z = 0; //Transform3Dto2D(x, y, z); //pDC-&gt;LineTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y));&#125; 效果图]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MFC的CDC类绘制二维坐标系及正余弦函数]]></title>
    <url>%2F2017%2F10%2F13%2FGraphicsExercise2D%2F</url>
    <content type="text"><![CDATA[系列链接 使用MFC的CDC类绘制二维坐标系及正余弦函数 / 源码 使用MFC的CDC类绘制三维坐标系及球面函数 / 源码 概述本文使用MFC的CDC类绘制二维坐标系及正余弦函数，可以进行坐标变换、规模变换，可以设置绘制的函数。通过输入自变量的范围及步长，绘制出相应的函数图形。 新建项目Visual Studio- 新建项目 - MFC应用程序 - 命名为CGraphicsExercise2D - 确定 - 下一步 - 应用程序类型选择单个文档 - 完成 绘制函数Visual Studio为我们创建了很多无用的代码，而我们的绘制函数在在CGraphicsExercise2DView.cpp的 void CGraphicsExercise2DView::OnDraw(CDC* /*pDC*/) { CGraphicsExercise2DDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 } 取消pDC的注释，变成 void CGraphicsExercise2DView::OnDraw(CDC* pDC) 在 // TODO: 在此处为本机数据添加绘制代码 下面编写你自己的程序，如画一条线： pDC-&gt;MoveTo(20, 30); // 画笔移到从左上角往右20像素、往下30像素 pDC-&gt;LineTo(100, 100); // 画一条线到右100、下100的位置 运行下看下效果吧！ 现在删掉上面两行那条线，开始正式编写二维坐标系了。 规模变换函数上面的MoveTo(20, 30)中的20、30是在显示器上的像素点，如果绘制的坐标系是以像素为大小的话，那1、2这样小的单位在显示器上就难以看到，因此需要规模变换。通常是把小单位乘上放大规模（倍数）就可以了。 在CGraphicsExercise2DView.h public: void SetScale(int scale); float TransformScale(float num); private: int scale; 在CGraphicsExercise2DView.cpp // 设置规模 void CGraphicsExercise2DView::SetScale(int scale) { this-&gt;scale = scale; } // 变换规模 float CGraphicsExercise2DView::TransformScale(float num) { return num * scale; } 并在CGraphicsExercise2DView()函数添加 // 设置规模比例 SetScale(70); 变换坐标和规模在CGraphicsExercise2DView.h public: float TransformCoordinateScaleX(float x); float TransformCoordinateScaleY(float y); 在CGraphicsExercise2DView.cpp // 变换x的坐标和规模 float CGraphicsExercise2DView::TransformCoordinateScaleX(float x) { return TransformScale(x + 2); } // 变换y的坐标和规模 float CGraphicsExercise2DView::TransformCoordinateScaleY(float y) { return TransformScale(y + 4); } 设置绘制的函数类型在CGraphicsExercise2DView.h 类外面定义 // 支持绘制的函数类型 enum Function { Sin, Cos }; 类里面定义 public: void SetDrawFunction(Function fun); private: Function fun; 在GraphicsExerciseView.cpp #include &lt;math.h&gt; // 设置绘制的函数 void CGraphicsExercise2DView::SetDrawFunction(Function fun) { this-&gt;fun = fun; } 并在CGraphicsExercise2DView()函数添加 // 设置绘制的函数 SetDrawFunction(Sin); 函数范围和步长设置正余弦函数的x取值范围如[0, 2*π]，设置x的取样步长如0.01。 在CGraphicsExercise2DView.h public: void SetPlotSin(float startX, float endX, float step); private: float startX, endX, step; 在CGraphicsExercise2DView.cpp // 设置范围和步长 void CGraphicsExercise2DView::SetPlotSin(float startX, float endX, float step) { this-&gt;startX = startX; this-&gt;endX = endX; this-&gt;step = step; } 并在CGraphicsExercise2DView()函数添加 // 设置自变量x范围[startX, endX]、取样步长step SetPlotSin((float)0.0, (float)6.3, (float)0.01); 绘制坐标系坐标系是距离左上角右下各2 * 规模个像素开始绘制的（即y轴的顶点是（2 * 放大规模, 2 * 放大规模）） 在OnDraw()函数的// TODO: 在此处为本机数据添加绘制代码下面添加如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// -------------------- 绘制坐标系 -------------------------float endPointX = 2 + endX + 2;// 坐标y轴pDC-&gt;MoveTo((int)TransformScale(2), (int)TransformScale(2));pDC-&gt;LineTo((int)TransformScale(2), (int)TransformScale(6));// 坐标x轴pDC-&gt;MoveTo((int)TransformScale(2), (int)TransformScale(4));pDC-&gt;LineTo((int)TransformScale(endPointX), (int)TransformScale(4));// 坐标y轴的箭头pDC-&gt;MoveTo((int)TransformScale((float)1.8), (int)TransformScale((float)2.2));pDC-&gt;LineTo((int)TransformScale(2), (int)TransformScale(2));pDC-&gt;LineTo((int)TransformScale((float)2.2), (int)TransformScale((float)2.2));// 坐标x轴的箭头pDC-&gt;MoveTo((int)TransformScale(endPointX - (float)0.2), (int)TransformScale((float)3.8));pDC-&gt;LineTo((int)TransformScale(endPointX), (int)TransformScale(4));pDC-&gt;LineTo((int)TransformScale(endPointX - (float)0.2), (int)TransformScale((float)4.2));// -------------------- 绘制刻度线 -------------------------// 绘制y轴刻度线for (float scaleY = 3; scaleY &lt;= 5; scaleY += 0.2)&#123; pDC-&gt;MoveTo((int)TransformScale(2), (int)TransformScale(scaleY)); pDC-&gt;LineTo((int)TransformScale((float)2.1), (int)TransformScale(scaleY));&#125;// 绘制x轴刻度线for (float scaleX = 2.2; scaleX &lt; endPointX - 1; scaleX += 0.2)&#123; pDC-&gt;MoveTo((int)TransformScale(scaleX), (int)TransformScale(4)); pDC-&gt;LineTo((int)TransformScale(scaleX), (int)TransformScale(3.9));&#125;// -------------------- 绘制文字 -------------------------// 绘制y轴的ypDC-&gt;TextOutW((int)TransformScale(1.8), (int)TransformScale(2.3), CString(&quot;y&quot;));// 绘制x轴的xpDC-&gt;TextOutW((int)TransformScale(endPointX - (float)0.5), (int)TransformScale(4.1), CString(&quot;x&quot;));CString s;// 绘制y轴刻度文字for (float ScaleTextY = 2.9, text = 1.0; ScaleTextY &lt;= 4.9; ScaleTextY += 0.2, text -= 0.2)&#123; s.Format(_T(&quot;%.1f&quot;), text); pDC-&gt;TextOutW((int)TransformScale(1.6), (int)TransformScale(ScaleTextY), s);&#125;// 绘制x轴刻度文字for (float ScaleTextX = 2.3; ScaleTextX &lt; endPointX - 1; ScaleTextX += 0.4)&#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextX - 1.9); pDC-&gt;TextOutW((int)TransformScale(ScaleTextX), (int)TransformScale(4.1), s);&#125;// 绘制函数图的Title// 判断调用的函数switch (fun)&#123;case Sin: pDC-&gt;TextOutW((int)TransformScale(4), (int)TransformScale(6), CString(&quot;y = sin( x )&quot;)); break;case Cos: pDC-&gt;TextOutW((int)TransformScale(4), (int)TransformScale(6), CString(&quot;y = cos( x )&quot;)); break;default: break;&#125; 绘制函数x从startX绘制到endX，每间隔step绘制一次。 也是在OnDraw()函数下面添加 1234567891011121314151617181920212223// -------------------- 绘制函数 -------------------------// 不改变坐标和规模的xyfloat x, y;for (x = startX; x &lt;= endX; x += step)&#123; // 判断调用的函数 switch (fun) &#123; case Sin: y = (float)sin(x); break; case Cos: y = (float)cos(x); break; default: break; &#125; // 对xy改变坐标和规模再显示点 pDC-&gt;SetPixel((int)TransformCoordinateScaleX(x), (int)TransformCoordinateScaleY(y), 0);&#125; 效果图]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决源码编译 ZeroC Ice 缺失 mcpp、bzip2、expat 库的问题]]></title>
    <url>%2F2017%2F09%2F06%2FCompileIceMissingLibrary%2F</url>
    <content type="text"><![CDATA[缺失 mcpp 库报错/usr/bin/ld: cannot find -lmcpp 解决 下载最新的 nux-dextop-release*rpm 包 http://li.nux.ro/download/nux/dextop/el7/x86_64/ 安装 nux-dextop-release 包 sudo rpm -Uvh nux-dextop-release*rpm 安装 mcpp sudo yum install libmcpp-devel 缺失 bzip2 库报错src/Ice/ConnectionI.cpp:32:21: fatal error: bzlib.h: No such file or directory # include &lt;bzlib.h&gt; ^ compilation terminated. make: *** [src/Ice/build/x64/shared/pic/ConnectionI.o] Error 1 解决sudo yum install bzip2-devel 缺失 expat 库报错src/IceXML/Parser.cpp:12:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^ compilation terminated. make: *** [src/IceXML/build/x64/shared/pic/Parser.o] Error 1 解决sudo yum install expat-devel]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>ZeroC-Ice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一加3T的刷机流程及玩机一些事]]></title>
    <url>%2F2017%2F08%2F27%2FOneplus3TBrushAndPlay%2F</url>
    <content type="text"><![CDATA[前言本文主要聊聊一加3T卡刷第三方Rom，包括刷 TWRP 的 Recovery，卡刷流程，初始化，安装及使用Xposed框架和Magisk框架。 选择Rom刷机前要选择要刷的系统，即选择Rom。 Rom无非官方Rom或者第三方Rom。 官方Rom有氢OS(H2OS)、氧OS(OxygenOS)。第三方Rom就很多了，如MIUI、Flyme、CM、AICP、LineageOS等等。 官方Rom一般比较稳定、适配性好、能接收推送；第三方Rom一般自定义程度高、可玩性高。 若是不想折腾还是官方Rom好；喜欢尝鲜可以试试第三方Rom。 官方Rom一加官方Rom有氢OS(H2OS)和氧OS(OxygenOS)。氢OS(H2OS)主要面向国内，本土化定制；氧OS(OxygenOS)主要面向国外，预装谷歌服务。官方Rom无论线刷还是卡刷都比较简单方便，在此就不做过多介绍。 氢OS(H2OS)下载：H2OS官方下载 氧OS(OxygenOS)下载：OxygenOS官方下载 第三方Rom本文主要聊聊一加3T卡刷第三方Rom。 第三方Rom在各大玩机论坛/Rom平台都能看到，如 官方论坛（推荐） xda-developers（推荐） 机锋Rom ROM之家 … 如一加3T的 一加社区 . 一加手机3T xda-developers . OnePlus 3T ROMs 我选了个OnePixel，这是个基于氧OS的类Pixel版Rom，喜欢原生的朋友可以给你的爱机食用： [ROM][EAS][DEODEXED][OB13] OnePixel, OOS Based Custom Rom with Pixel Experience 效果图 安装 TWRP因为一加官方 Recovery 功能较弱，所以先刷个 TWRP Recovery。 下载 TWRP选择自己机型的TWRP下载 https://twrp.me/Devices/ 如我的一加3T下载的TWRP文件为： twrp-3.1.1-2-oneplus3t.img 安装 ADB安装 ADB 可以使用一些一键安装工具（如：15秒ADB安装器）或者下载官方 Android SDK 的 platform-tools 启用USB调试不管哪种方式都需要首先将手机连上电脑，启用USB调试。 设置 &gt; 开发人员选项 &gt; USB调试 使用15秒ADB安装器安装 作者发的帖子: [TOOL] [WINDOWS] ADB, Fastboot and Drivers - 15 seconds ADB Installer v1.4.3 国内百度云盘下载： 链接：http://pan.baidu.com/s/1c1FWmTM 密码：vg0g 使用 Android SDK 的 platform-tools 安装下载 platform-toolsWindows版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-windows.zip 网盘下载链接：http://pan.baidu.com/s/1eRG8gXs 密码：72ac MacOS版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-darwin.zip 网盘下载链接：http://pan.baidu.com/s/1pLQFvrt 密码：7qav Linux版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-linux.zip 网盘下载链接：http://pan.baidu.com/s/1nu8mvrF 密码：giug 安装解压，进入 platform-tools 目录 把twrp-3.1.1-2-oneplus3t.img文件复制到platform-tools目录下，终端使用 adb reboot bootloader 进入bootloader模式，输入命令 fastboot flash recovery twrp-3.1.1-2-oneplus3t.img 进行安装TWRP。 刷机（卡刷）Wipe - 清理系统和缓存进入TWRP后，首先Wipe 进入Wipe - Advanced Wipe 勾选 Dalvik/ART Cache Cache Data System 划过 Swipe to Wipe 来 Wipe 注：下面两个不用勾选 Internal Storage 是数据存放的地方 USB-OTG 是与支持USB-OTG设备的连接 Install - 安装Rom连上电脑在TWRP模式下，把下载的Rom拷贝到Internal Storage，然后在Install里面找到你的Rom，如 OnePixel_OB13_oneplus3t-7.1.1rc.zip 划过Swipe to confirm Flash进行安装，装好后重启进入系统。 初始化设置进入系统后进行初始化设置 注意：WiFi/数据连接没代理不要连接，断网设置，不然会一直连接不上Google而卡在那里的。 初始化好之后设置了些东西就是这样子啦 Xposed框架大名鼎鼎的Xposed框架，可以通过添加各种模块实现各种功能，不过官方版现在才更新到适配Android6.0 官方链接：Xposed Installer 好在XDA社区有 Material Design 版的Xposed框架下载器（推荐） xda-developers . Material Design Xposed Installer 安装 Material Design Xposed Installer 后在 UnOfficial 这栏选择适合自己手机型号的Xposed框架下载 装好Xposed框架后，下载Xposed模块 知乎上有些好的Xposed模块推荐 知乎 . Android 系统上的 Xposed 框架中都有哪些值得推荐的模块？ Magisk框架Magisk是类似xposed的第三方应用接口，但是暂时模块较少。 Magisk的介绍、下载、安装 [2017.7.20] Magisk v13.3 - Root &amp; Universal Systemless Interface [Android 5.0+] 下面是安利Magisk的帖子，里面有各种模块介绍： [教程] (搬运XDA)magisk框架教程以及模块-xposed的替代品 我因为OnePixel Rom自带Magisk，也就顺便装了个Pixel Launcher transparent dock，让pixel luncher底栏的颜色变透明。 效果如上面初始化设置那里的截图。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装配置Shadowsocks客户端及开机自动启动]]></title>
    <url>%2F2017%2F08%2F25%2FLinuxInstallConfigShadowsocksClient%2F</url>
    <content type="text"><![CDATA[前言 Shadowsocks无GUI客户端教程：Linux安装配置Shadowsocks客户端及开机自动启动 Shadowsocks-Qt5客户端教程：Shadowsocks-Qt5 For Centos 7 Shadowsocks服务端教程：搬瓦工Shadowsocks安装及配置多用户(服务端) 安装Debian/Ubuntu:apt-get install python-pip pip install shadowsocks CentOS:sudo yum install python-setuptools &amp;&amp; easy_install pip sudo pip install shadowsocks 配置找个地方放shadowsocks的配置文件，一般放到 /etc下面： sudo vi /etc/shadowsocks.json 我放在我的用户目录下，因为有时需要修改，放在这里方便些： vi /home/xx/Software/ShadowsocksConfig/shadowsocks.json 你可以根据自身情况考虑。 然后在shadowsocks.json里面添加配置信息，如： { &quot;server&quot;:&quot;my_server_ip&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;server_port&quot;:my_server_port, &quot;password&quot;:&quot;my_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot; } 把 my_server_ip改为自己的服务器IP my_server_port改为自己的服务器端口 my_server_password改为自己的密码 method的值改为自己的加密方式，一般是aes-256-cfb或者rc4-md5 详细配置说明： Name 说明 server 服务器地址，填ip或域名 local_address 本地地址 local_port 本地端口，一般1080，可任意 server_port 服务器对外开的端口 password 密码，可以每个服务器端口设置不同密码 port_password server_port + password ，服务器端口加密码的组合 timeout 超时重连 method 默认: “aes-256-cfb”，见 Encryption fast_open 开启或关闭 TCP_FASTOPEN, 填true / false，需要服务端支持 保存退出就配置好啦！ 设置代理系统代理可以选择系统代理，就如下图配置就好啦： 但是系统代理是全局走代理的，访问国内网站一般会有限制（速度较慢、浪费流量、版权受限等）。 所以推荐下面的用浏览器按照规则选择性代理。 浏览器代理安装 SwitchyOmega 插件以 Chrome 为例，安装 SwitchyOmega 插件代理。 Github 下载 SwitchyOmega：https://github.com/FelisCatus/SwitchyOmega/releases/ Chrome 打开chrome://extensions/，把插件托进去安装。 配置 Proxy Server填写shadowsocks.json配置中的local_address Port填写shadowsocks.json配置中的local_port 左边Apply changes保存。 配置 Auto Switch Rule list rules的Profile填proxy Default的Profile填[Direct] Rule List Format选择AutoProxy Rule List URL填写gfwlist的规则: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 下载规则文件Download Profile Now 左边Apply changes保存 启用 SwitchyOmega启用 SwitchyOmega 插件，选择 Auto Switch 模式就可以了。 测试启动配置文件的路径改成自己的，如：/etc/shadowsocks.json 前端启动：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json； 后端启动：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json -d start； 后端停止：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json -d stop； 重启(修改配置要重启才生效)：sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json -d restart 开机自启以下使用Systemd来实现shadowsocks开机自启。 sudo vim /etc/systemd/system/shadowsocks.service 在里面填写如下内容： [Unit] Description=Shadowsocks Client Service After=network.target [Service] Type=simple User=root ExecStart=/usr/bin/sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json [Install] WantedBy=multi-user.target 把/home/xx/Software/ShadowsocksConfig/shadowsocks.json修改为你的shadowsocks.json路径，如：/etc/shadowsocks.json 配置生效： systemctl enable /etc/systemd/system/shadowsocks.service 输入管理员密码就可以了。 现在你可以马上重启试试，或先在后台启动，等下次重启再看看！]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过直接添加或者手动编译添加库，解决 library not found for -lxxx 等的问题]]></title>
    <url>%2F2017%2F08%2F23%2FAddLibraryToSolveLibraryNotFound%2F</url>
    <content type="text"><![CDATA[前言本文基本上能完美解决这种库文件无法找到问题。 文中以IceUtil库为例子，你可以推广到其他库，方法相同。 问题描述在 Mac 下用 Homebrew 安装 ZeroC Ice 这个中间件后发现 IceUtil 库缺失，IDE 报了个链接错误，如下图： 问题分析这个问题是说链接器在链接的时候找不到 IceUtil 这个库，那我们就告诉它（添加库的路径），让它找到就好啦！ 扩展： 静态库无法链接报错： library not found for -lxxx 动态库无法装载报错： dyld: library not loaded …/libxxx.dylib 解决办法方法一：直接添加库通常解决办法是：库存在，直接添加路径。 也就是通常遇到这个问题的时候，库是已经编译安装好了的，但是 IED 不能找到。这样的话就直接添加库的路径就好了。 第一步：找库第一步，自己找到这个库。 库一般放在系统默认处或者安装到特定地方。 Linux 系统默认库放在： /lib /usr/lib /usr/local/lib ... 安装到特定地方，如我 Mac 的用 Homebrew 安装到： /usr/local/Cellar/ice/3.7.0/lib 第二步：添加路径添加库一般以下三种方法任选其一： 系统环境变量添加 系统级：修改/etc/profile或者/etc/bashrc 用户级：修改~/.bashrc或者~/.bash_profile #添加库的bin文件夹路径 export PATH =$PATH:$HOME/bin #添加到gcc头文件 export C_INCLUDE_PATH=$C_INCLUDE_PATH:/MyLib #添加到g++头文件路径 export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/MyLib #添加到动态库 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib #添加到静态库 export LIBRARY_PATH=$LIBRARY_PATH:/MyLib IED 编译环境添加 因 IDE 不同而不同，如 Qt 在项目-构建设置-构建环境处添加 具体请参考：QT 无法链接动态库 dyld library not loaded … libhdf5.100.dylib 代码添加 # 如 Qt pro 文件添加 LIBS += -L/usr/local/Cellar/ice/3.7.0/lib -lIceUtil 这样，IDE就能找到库啦！ 方法二：手动编译添加库若是你的库不存在，也就是说安装的时候没有编译生成这个库文件或者安装后莫名的不见了，这样只能重新安装或者手动编译添加库。以下讲手动编译添加库。 思路是：找库，如果找不到，手动编译生成库文件，拷贝到库文件目录，用上面添加路径的方法添加路径让IDE找到。 第一步：找库对的，还是要找找的，不然怎么知道没有呢！[捂脸] 可以在一些常放库的文件夹下找，尽量靠近根目录，如： sudo find /usr -name &quot;libIceUtil*&quot; 扩展： 如果找到名为libIceUtil.3.7.0.a的库，但是找不到libIceUtil.a的库，可以试着拷贝libIceUtil.3.7.0.a库成名为libIceUtil.a的库 cp ./libIceUtil.3.7.0.a ./libIceUtil.a 这个方法适用于： 同版本下，缺失没版本号的库文件 不同版本下，库文件没因为版本的改变而发生改变 第二步，手动编译#因为IceUtil是Ice的库，所以克隆下Ice来 git clone https://github.com/zeroc-ice/ice.git #因为我需要的是C++版 cd ice/cpp #直接编译 make 编译好后就能找到这个库了：cpp/lib/libIceUtil.a 其他库请参考官方的编译安装教程 附：Building Ice for C++ on macOS 第三步，拷贝库到安装后的文件夹到ice/cpp/lib目录下： cp ./libIceUtil.a /usr/local/Cellar/ice/3.7.0/lib 第四步：添加路径上面已经说了三种方法，这里直接代码添加： # 如 Qt pro 文件添加 LIBS += -L/usr/local/Cellar/ice/3.7.0/lib -lIceUtil 这样就解决了！ 唠叨以上这些方法基本上能完美解决这种库文件无法找到问题，如果有本文没有提及的欢迎留言讨论。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal 源码编译运行 Missing cached shader map... 的问题]]></title>
    <url>%2F2017%2F07%2F28%2FUnrealMissingCachedShaderMap%2F</url>
    <content type="text"><![CDATA[Unreal 源码编译运行 Missing cached shader map… 的问题问题描述Unreal 源码是 Github-release 分支，版本是4.16。 编译运行Unreal引擎源码的时候，出现虚幻编辑器的窗口，但是卡在45%不动。 并在调试窗口输出： Missing cached shader map for material WorldGridMaterial, compiling. Is special engine material. 同类问题同样这个问题，在unrealengine社区有人遇到，但没有说明具体原因及解决方案。 answers.unrealengine.com - UE4.7 source build, missing cached shader 结果结果我没有进行任何操作，再等会儿 居然成功运行了起来！ 我猜测可能是WorldGridMaterial这个材质需要联网下载，然后由于网络问题在45%处卡住了一会儿。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Launcher 启动 UE4 引擎出现 An Unreal process has crashed 的问题]]></title>
    <url>%2F2017%2F07%2F28%2FAnUnrealProcessHasCrashed%2F</url>
    <content type="text"><![CDATA[Launcher 启动 UE4 引擎出现 An Unreal process has crashed 的问题问题描述在 Launcher 启动 UE4 引擎，引擎奔溃，出现奔溃报告： An Unreal process has crashed:UE4-…… 解决以管理员身份运行 Launcher，并启动 UE4 引擎则能正常启动。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc/mpicc 编译器 undefined reference to ... 问题的解决]]></title>
    <url>%2F2017%2F07%2F18%2FUndefinedReferenceTo%2F</url>
    <content type="text"><![CDATA[描述我的代码中使用了libcstl库，在代码中声明： #include &lt;cstl/cmap.h&gt; 可是出现这个问题，无法识别libcstl库里调用的函数，如下图： 猜想 #include &lt;cstl/cmap.h&gt;这句话不报错说明库已经装好，环境变量也没有问题。 可能是链接时的错误。 解决查看Makefile文件发现忘记添加cstl的链接库了。 -lcstl 原来的代码是： mpicc -c main.c -std=c99 -lstdc++ -fopenmp -lm -o main.o 应该改为： mpicc -c main.c -std=c99 -lcstl -lstdc++ -fopenmp -lm -o main.o 如上图，改好之后就解决了！]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[std::map error: implicit instantiation of undefined template 不能识别std::map迭代器指针]]></title>
    <url>%2F2017%2F07%2F17%2FStdMapTheIteratorPointerIsNotRecognized%2F</url>
    <content type="text"><![CDATA[std::map error: implicit instantiation of undefined template 不能识别std::map迭代器指针代码如下： std::map&lt;std::string, int&gt;::iterator map_iter; map_iter-&gt;first QT中报错： /Applications/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility:258: error: implicit instantiation of undefined template &apos;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;&apos; _T1 first; ^ 发现是引入头文件错误。 我原本头文件引入如下： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;map&gt; 应该 #include &lt;string&gt;，而不是 #include &lt;string.h&gt;，修改为如下： #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT QDialog 中模态与非模态对话框的研究]]></title>
    <url>%2F2017%2F06%2F29%2FQTQDialogModal%2F</url>
    <content type="text"><![CDATA[模态与非模态对话框模态对话框模态对话框是只能首先对其进行操作后才能操作其他窗口的对话框。实质是父线程在子线程创建这个模态对话框后，父线程阻塞，等待子线程的操作。 非模态对话框非模态对话框则是可以同时对它和其他窗口进行操作的对话框。实质是父子进程并行运行。 QDialog概述 The QDialog class is the base class of dialog windows. QDialog 类是对话框窗口的基类。用于创建对话窗口。 继承关系class Q_WIDGETS_EXPORT QDialog : public QWidget QT 窗口模态模态种类enum WindowModality { NonModal, WindowModal, ApplicationModal }; 状态 Constant Value 描述 QDialog代表方法 非模态 Qt::NonModal 0 窗口不是模态，不会阻止其他窗口的操作 QDialog::show() 窗口模态 Qt::WindowModal 1 窗口对单个窗口层次结构是模态，会阻止对其所有长辈（父窗口、祖父窗口、他们的兄弟姐妹）的操作，其子窗口不会阻止 QDialog::open() 应用模态 Qt::ApplicationModal 2 窗口对应用程序是模态，并阻止对所有窗口的操作 QDialog::exec() 注意：窗口模态与应用模态都属于模态，只是WindowModal对局部模态，ApplicationModal对整个程序模态。 设置模态定义class Q_WIDGETS_EXPORT QWidget : public QObject, public QPaintDevice { public: void setWindowModality(Qt::WindowModality windowModality); } 使用QDialog dialog; dialog.setWindowModality(Qt::ApplicationModal);]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机会总是留给有准备的人 —— 从裁缝到码农]]></title>
    <url>%2F2017%2F06%2F14%2FChanceLeftPerson%2F</url>
    <content type="text"><![CDATA[序言2014年8月，一个男生拿着广工服装工程专业的录取通知书来到东风路，望着学校大门，想着：“这就是我的大学？” 2014年11月，一个男生一个女生望着广工大学城的大门，女生憧憬着：“别人家的大学真漂亮呀”，男生笑了：“对呀，别人家的大学真漂亮。” 2016年8月，一个男生拿着一张转专业通知书路过广工大学城大门，驻足远望，想着：“这就是我的大学！” 裁缝，我没准备依稀记得高考填自愿的那年夏天，闷热的风吹躁了我的心。老师和长辈们都说，先选学校，再选专业。你出去别人首先看你的学校，并且大学基本上靠自学，还可以修双专业，所以专业不重要。那时，我还不知道大学是什么样子，只是一腔热血地喜欢计算机，也只知道许多大神都是自学甚至辍学的。因此，我在第一志愿广工的最后一栏填了“服从调配”四个字。就是这四个轻率毫无准备的字，让我走上一条野路。 录取通知出来了，我两眼呆滞地看着那行录取信息，广东工业大学，艺术设计学院，服装设计与工程。我内心瞬间模拟了一次宇宙大爆炸，颤抖地扶着墙，缓慢移出房间，告诉父母我被广工录取了，专业是……是那什么鬼呀？ 我费了好一会儿功夫才模糊知道这个专业是做什么的。服装设计与工程，就是设计衣服加做衣服。那一刻，我后悔了。我想起高三桌子右上角的座右铭，是在《仙剑》看到的“我命由己不由天”，而此时，我似乎听到了老天的奸笑，“嘿嘿，小子，这就是你的命”。 我没准备，因此录了服装工程。我对自己说，你不是说自学都行吗？自己选的路，跪着也要走完！野路子出身也能成为大神！ 码农，我准备着就这样，我来到了东风路，来到了我的大学。破冰，军训，选班干，加社团，搞活动，交朋友，到处玩，到处浪。大学丰富多彩的活动吸引着我，让我暂时忘却烦恼。等到渐渐习惯大学的生活后，作为新生的激情归于沉寂，随之而来的就是深深地迷茫。 你问可以转专业吗？我也问过辅导员，辅导员说基本上不可以，虽然学生手册中有这种操作，但是他还没见过有人转成功过，因为学校还没有明确的政策。有人问我为什么不试着喜欢上这个专业呢？我想了想，说：“就像喜欢一个人，一旦喜欢上，心就容不下别人”。 自学计算机？要学什么？怎么学？学了以后有出路吗？黑夜不可怕，最可怕的是没有黎明的黑夜。我迷茫着。 幸好，我遇到了个很好的思修老师，她讲的关于“梦想、理想、方向”的理解让我有种醍醐灌顶的感觉。虽然我梦想很远，甚至看不到，那我就只需要朝着这个方向努力，为此准备着，等到时机成熟，量变引起质变的时候，就会发现，其实，梦想触手可及。 就这样，我带着一抹执念，走上一条野路。从谭浩强的《C程序设计》，到郝斌的C语言、数据结构教程，我初窥编程门径。想着杨昌济对毛泽东说的：“修学储能,先博后渊”，我就真的傻傻的“博”学了遍，学了C++、Java，也学了前端、安卓，甚至还玩了单片机。现在想想真是后悔死了，学而不精等于没学。 但是，不管怎样，我还是在这条野路上走着、准备着，即使走得慢，即使走了弯路，即使看不到希望。 转专业，我准备了大二下的某一天，我意外地知道了学校今年有转专业的政策，我内心似乎有股火苗在燃烧，我不相信，当即去问辅导员，等到确认后心还是躁动着。慢慢地，我又有些担忧，转专业呀，听说都要专业第一第二名的水平呀，我一个不怎么学服工自学计算机的，不会绩点就不达标吧。当机会摆在我眼前的时候，我是否有能力抓住？仔细想想，看来我准备地还不够呢。我还是交了转专业申请表，不报白不报嘛，万一成功了呢。 转专业考核的内容是C语言和离散数学。离散是没有学过的，所以我就开始自学了。离散的一堆概念真是令人头疼，好在一位计算机学院的同学给了我离散往年题目，才慢慢学完。 考核分两轮：绩点和笔试面试。第一轮绩点刷人，我和一老哥并列最后，因为刚开始施行这个政策，转专业人的绩点还没高到那种程度呢，好险！第二轮的笔试，和我并列的那老哥竟然C和离散之前都没学过，只是狂看了几天就来考核了，我服！原来他之前不知道考核内容，但当时已经在一家公司搞着前端项目了。面试的时候，我当天机智的穿了印有 Google Logo 的衣服，吹着我的信仰，结果面试官果然被我的人(zou)格(gou)魅(si)力(yun)折服，最终我以笔试面试总成绩专业第一被录取了！ 看到结果的那一刻我的心快要跳出来了，我不敢相信，害怕这美丽的梦，触碰就破碎。我伸出颤抖的手去抓，发现曾经遥不可及的梦想，经过坚持和努力之后，真的可以抓住。我把它抓在手心，紧紧地。 未来，我准备着现在，我已经在广工大学城计算机专业读了快一年了。因为专业跨度大，需要重读一年大二并补上大一的课，每天的课也满满的，却也充实。 来到这边才发现，在计算机这种专业性质强的专业，科班与非科班的差距还是很大的。师资力量、设备环境、专业指导等都是非科班、野路子所接触不到的，但是我觉得最大的差距还是人脉、氛围、眼界。在服工，根本没有这个氛围，也不知道他们计算机专业每天都在学些什么，唯有一个人摸索，唯有去网上找答案，这让我觉得恐怖也庆幸。 在这边，我进了工作室，有了以后的方向，也开始写博客，玩 Github ，越来越发现身边有很多大神，越来越发现我只是略懂皮毛，越来越发现原来我之前走的很多路都是弯路。 但是，不管怎样，我还是在这条路上走着、准备着，即使走得慢，即使走了弯路，但我总算有了伙伴，有了希望。 未来，我准备着，你准备了吗？ 以下不作为正文，仅以我的经验总结出的几点感悟，望共勉： 机会总是留给有准备的人 当机会摆在你眼前的时候，你是否有能力抓住？ 信息很重要 自己选的路，跪着也要走完！ 现在的社会需要的是精一而不是通百的人才 虽然梦想很远，甚至看不到，那就只需要朝着这个方向努力，为此准备着，等到时机成熟，量变引起质变的时候，就会发现，其实，梦想触手可及。 修电脑的裁缝酱 2017年06月14日于广东工业大学]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活是一首诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT 无法链接动态库 dyld library not loaded ... libhdf5.100.dylib]]></title>
    <url>%2F2017%2F06%2F05%2FQtDyldLibraryNotLoaded%2F</url>
    <content type="text"><![CDATA[qt dyld library not loaded …/libhdf5.100.dylib 分析无法链接动态库，考虑手动添加链接。 找到 libhdf5.100.dylib 文件及路径 /usr/local/opt/hdf5/lib 添加到 QT Run Environment把路径添加到Run Environment中的DYLD_LIBRARY_PATH变量的值中。 若无此变量则添加，若已有则按编辑并在后面加上路径。 Run! 补充：添加到构建设置-构建环境中如果添加到 Run Environment 中还是不行，可以添加到Build-构建设置-构建环境中。 Debug! Thanksstackoverflow . qt mac osx 10.8 dyld: library not loaded…image not found]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 构建静态文件无法生成 index.html 等文件]]></title>
    <url>%2F2017%2F05%2F13%2FHexoNPMERR%2F</url>
    <content type="text"><![CDATA[hexo g 无法生成 index构建情况如下图： 但是一些文件没有生成，如 index.html 文件。 查看 npm 安装各 hexo 插件的情况npm ls --depth 0 hexo 的一些插件未安装插件npm ERR! missing npm ERR! missing hexo-generator-archive… 解决逐一安装缺失的包 npm install hexo-generator-archive --save ... 安装完后重新构建即可解决。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare插件编写一（插件框架）]]></title>
    <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_1_Framework%2F</url>
    <content type="text"><![CDATA[唠叨本文唠叨了些CloudComapre这个开源软件的插件编写。 虽然这篇是入门教程，但是作为一只有梦想的程序猿，怎能像很多入门教程那样写个残缺的入门教程呢！ 所以这是一个完整插件的入门教程，我们要写的插件是qSAF(Scan Angle Filter)，这是可以过滤给定范围内点的扫描角度的插件。 下面分三篇来介绍，分别是插件框架篇、数据结构篇、算法实现篇。 这是第一篇，插件框架篇，你可以根据本文改成自己的插件，待卿临幸。 特别注意：本文的CloudCompare源码构建的是Qt工程并使用Qt Creator开发，并不是Visual Studio。 qSAF源码：Github . qSAF CloudComapreCloudComapre是一个开源的3D点云和网格的处理软件，开可以处理各类点云格式的数据。 官网：http://www.cloudcompare.org/ Github：https://github.com/cloudcompare/cloudcompare CloudComapre插件编写使用qDummyPlugin插件模板创建自己的插件【2018年5月30日改：现在Github上CloudComapre仓库的master分支已经移除qDummyPlugin插件，取而代之的是 ExamplePlugin插件： CloudCompare/plugins/example/ExamplePlugin ，原qDummyPlugin插件可在2.9.x分支或者其他早期分支上找到：qDummyPlugin】 首先在Github上git下CloudComapre的源码， 再到 CloudComapre/plugins/qDummyPlugin 下 这个qDummyPlugin就是个插件的模板，用它来写自己的插件。 我们把这个模板插件文件夹拷贝一份，改为自己的插件名qSAF（当然，你也可以改为其他你喜欢的，以下不做累述） 现在qSAF里面有如下几个文件 我们需要做的是把里面的qDummyPlugin及类似的名字改为自己的qSAF。 注意：文件名和文件里面内容都要修改！ 如： 原本CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) #REPLACE ALL &apos;DUMMY&apos; OCCURENCES BY YOUR PLUGIN NAME #AND ADAPT THE CODE BELOW TO YOUR OWN NEEDS! option( INSTALL_QDUMMY_PLUGIN &quot;Check to install qDUMMY plugin&quot; OFF ) # CloudCompare &apos;DUMMY&apos; plugin if (INSTALL_QDUMMY_PLUGIN) project( QDUMMY_PLUGIN ) #load necessary libraries (see qPCV for an example) #add_subdirectory (LIB1) #if the plugin is an &apos;OpenGL filter&apos;, uncomment the line below #set( CC_OPENGL_FILTER ON BOOL) include( ../CMakePluginTpl.cmake ) #set dependencies to necessary libraries (see qPCV for an example) #target_link_libraries( ${PROJECT_NAME} LIB1 ) #include_directories( ${LIB1_INCLUDE_DIR} ) endif() 修改后的CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) option( INSTALL_QSAF_PLUGIN &quot;Check to install qSAF plugin&quot; OFF ) if (INSTALL_QSAF_PLUGIN) #CloudCompare ‘SAF’ plugin project( QSAF_PLUGIN ) include( ../CMakePluginTpl.cmake ) endif() 剩下的qSAF.h、qSAF.cpp和qSAF.qrc就不一一列出了 修改后变成这样： 使用qmake构建pro文件在终端进入到你的插件的qSAF目录，执行： qmake -project -r CMakeLists.txt 就会在qSAF目录下构建一个项目的pro文件。 导入工程到QT现在把CloudComapre导入到QT， 在CloudComapre-plugins-plugins.pro中，加上自己的插件： 保存刷新后就会在项目上看到了。 pro文件编写由于qmake自动生成的pro文件不适合我们要写的插件，所以要自己修改pro文件。 pro文件的编写可以参考： QT的pro文件编写 里面的常规pro文件就是qSAF的。 里面的路径可以不用修改，具体看你项目的Release生成的位置， 特别注意：指定生成路径中的libs和plugins要正确 完成模板插件框架没错！这就完成了，你的插件已经做出来了！现在可以Run一下或者Debug一下看看啦~ 选中点云，使用qSAF，会这样： 莫慌！这是正常现象，因为你的qSAF具体实现还没有写呢！ 遇到问题1. 编译出错可能原因： qSAF.h、qSAF.cpp和qSAF.qrc这三个文件里面的qDummyPlugin及类似的名字要改为自己的qSAF，如果改错或没改，可能报错。 自己写的代码有错，这个视情况而定 2. 运行的CloudComapre插件上没有你编写的插件的快捷方式可能原因 插件的生成路径出错了，自己插件的pro文件中的plugins指定生成路径要正确。 个性化插件现在来个性化一下我们的插件 在qSAF.h中： // 设置插件的唯一ID Q_PLUGIN_METADATA(IID &quot;cccorp.cloudcompare.plugin.qSAF&quot;) // 设置插件名字 virtual QString getName() const override { return &quot;SAF&quot;; } // 设置插件的描述 virtual QString getDescription() const override { return &quot;Filter the scanning angle in a range of points&quot;; } // 设置插件图标，这个要在 qSAF.cpp 里设置图标路径 virtual QIcon getIcon() const override; // 设置插件要执行的操作（重点） void doAction(); 插件doAction()我们编写插件是要做些事情，在CloudComapre插件中就是在doAction()中实现按下插件SAF后要做的事。 这个函数在qSAF.cpp中，你会发现复制的模板插件的doAction()是这样的（把qDummyPlugin改为qSAF啦）： void qSAF::doAction() { //m_app should have already been initialized by CC when plugin is loaded! //(--&gt; pure internal check) assert(m_app); if (!m_app) return; /*** HERE STARTS THE ACTION ***/ //put your code here //--&gt; you may want to start by asking parameters (with a custom dialog, etc.) //This is how you can output messages m_app-&gt;dispToConsole(&quot;[qSAF] Hello world!&quot;,ccMainAppInterface::STD_CONSOLE_MESSAGE); //a standard message is displayed in the console m_app-&gt;dispToConsole(&quot;[qSAF] Warning: qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::WRN_CONSOLE_MESSAGE); //a warning message is displayed in the console m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); //an error message is displayed in the console AND an error box will pop-up! /*** HERE ENDS THE ACTION ***/ } 我们要做的就是在 /*** HERE STARTS THE ACTION ***/ 下面写自己的插件代码。 刚才你看的错误信息就是这句： m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 这是控制台输出的错误信息。 错误信息(ERR_CONSOLE_MESSAGE)同时在控制台和窗体形式出现，而其他标准信息(STD_CONSOLE_MESSAGE)、警告信息(WRN_CONSOLE_MESSAGE)，则只在控制台显示。 现在删掉/*** HERE STARTS THE ACTION ***/下面的，改为自己的一句： m_app-&gt;dispToConsole(&quot;[qSAF] 程序是从错误开始的！&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 结果如下： 插件框架完成现在已经完成了插件框架的编写啦。 其实只要使用CloudComapre提供的插件模板qDummyPlugin，改成自己的就可以啦。 现在可以发挥你的想象力，在doAction()里面随心所欲地做各种事情啦。 但是只有框架还不够，要想对点云进行操作，和SAF功能的具体实现，还需要了解CloudComapre中点云的数据结构： CloudComapre插件编写二（数据结构） 如果你对点云数据结构虐它如虐狗，可以戳这里： CloudComapre插件编写三（算法实现）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare插件编写二（数据结构）]]></title>
    <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_2_DataStructure%2F</url>
    <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第二篇，数据结构篇，你可以根据本文改成自己的插件，待卿临幸。 特别注意：本文的CloudCompare源码构建的是Qt工程并使用Qt Creator开发，并不是Visual Studio。 qSAF源码：Github . qSAF 前文概要在上回中，我们已经实现了插件的框架，现在要在doAction()中写插件的具体实现。 插件需求我们要做的是一个qSAF(Scan Angle Filter)插件，它可以过滤给定范围内点的扫描角度。 也就是用户输入两个角度值，如20度、70度， 过滤输出每个点的扫描角度在大于等于20度、小于等于70度的范围的点云。 需求分析要实现这个功能，我们需要有一个界面，可以让用户输入两个角度，然后获取两个角度值，接着遍历每个点，获取每个点的扫描角度，然后获得角度在大于等于20度、小于等于70度范围的点云，显示输出。 简单地说，就是要： 输入界面 遍历角度 输出点云 1. 输入界面是QT基础；3. 输出点云是CC套路；只有2. 遍历角度有点纠结。 因此本文第二篇主要介绍2. 遍历角度，即介绍点云中点的数据结构。 注意：不同类型文件的数据结构不同，本文以激光雷达文件(.las)来做介绍。 las文件的读入首先，我们从宇宙的起源开始说起…… 额，还是从.las文件的读入开始说起吧~ .las文件的读入首先进过FileIOFilter这个类，判断是雷达文件(.las)后，进入LASFilter类，并从它的loadFile()函数读入。 先看下loadFile()函数声明： virtual CC_FILE_ERROR loadFile(QString filename, ccHObject&amp; container, LoadParameters&amp; parameters) override; 特别注意三个传入参数！我就是忽视了这里才找了好久。。。 QString filename 是点云文件名（包括路径） ccHObject&amp; container 是一个实体（ccHObject），可以添加点云（ccPointCloud） LoadParameters&amp; parameters 是选择读入文件后提示要勾选雷达的哪些信息 然后看下loadFile()函数体 .las文件首先从io流读入，再使用liblas这个外部库存储： liblas::Reader reader(liblas::ReaderFactory().CreateWithStream(ifs)); 这里说下liblas： liblas是用于读取和编写非常常见的LAS LiDAR格式的C/C++库，我们使用它来做对LAS的直接读取。 官网如下： https://www.liblas.org/ 然后把liblas读入的文件进行各种处理和封装，最终封装成ccPointCloud ccPointCloud* loadedCloud = 0; int sfIndex = loadedCloud-&gt;addScalarField(field-&gt;sf); ... loadedCloud-&gt;setName(chunkName); ... loadedCloud-&gt;setMetaData(LAS_SCALE_X_META_DATA, QVariant(lasScale.x)); ... loadedCloud-&gt;addPoint(P); ... 然后通过： container.addChild(loadedCloud); 添加到ccHObject中 所以：点云的信息，都是存储在ccPointCloud中的！ 而扫描角度存储在ccPointCloud的标量域中(ccScalarField) ccPointCloud前面已经说了很多ccPointCloud了，它就是CloudCompare中存储点云的类。 我们看看它的说明 //! A 3D cloud and its associated features (color, normals, scalar fields, etc.) /** A point cloud can have multiple features: - colors (RGB) - normals (compressed) - scalar fields - an octree strucutre - per-point visibility information (to hide/display subsets of points) - other children objects (meshes, calibrated pictures, etc.) **/ 我要的扫描角度就在scalar fields 然而在ccPointCloud没有直接的方法获得众多标量域中的扫描角度 终于在它的父类ChunkedPointCloud中发现了 ChunkedPointCloudccPointCloud的父类ChunkedPointCloud中有如下两个函数： # 通过标量域名字获得其在标量域数组中的索引 int ChunkedPointCloud::getScalarFieldIndexByName(const char* name) const # 通过索引获得特定标量域的指针 ScalarField* ChunkedPointCloud::getScalarField(int index) const 通过这两个函数就可以获得指向扫描角度的指针了，要想访问扫描角度中每个点的值，需要使用ScalarField父类GenericChunkedArray的方法 GenericChunkedArray# 通过每个点的索引访问特定标量域的每个的的值 inline const ElementType* getValue(unsigned index) const LASOpenDlg标量域中扫描角度的名字可以在LASOpenDlg.h中找到 &quot;Scan Angle Rank&quot; 整理下思路 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 这样就获取到了每个点的扫描角度值，然后： 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 上面整理的思路在下篇实现，现在我们已经知道怎么获取点云中扫描角度的值了，那其他信息呢？ 点云其他信息的获取看下在QT的调试信息： 我们可以发现，其实点云的信息都能在ccPointCloud中获取，比如点容量、点数量、点坐标、标量域、颜色值等。 其中，标量域vector中有9项信息，存储的标量域顺序为： [0] Point Source ID [1] Scan Angle Rank [2] Flightline Edge [3] Scan Direction [4] Number of Returns [5] Return Number [6] Time [7] Intensity [8] Classification 至于如何获取每种数据，都有相应的方法实现，不是在ccPointCloud，就是在它的父类中，耐心点总能找到的~ 下篇概要下篇是算法实现篇，主要说了qSAF插件的具体实现，包括上面说的： 输入界面 遍历角度 输出点云 请戳这里： CloudComapre插件编写三（算法实现）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare插件编写三（算法实现）]]></title>
    <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_3_Algorithm%2F</url>
    <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第三篇，算法实现篇，你可以根据本文改成自己的插件，待卿临幸。 特别注意：本文的CloudCompare源码构建的是Qt工程并使用Qt Creator开发，并不是Visual Studio。 qSAF源码：Github . qSAF 前文概要在上回中，我们知道了点云中扫描角度的存储结构，下面我们来讲qSAF的具体实现。 UI界面新建QT设计器界面类，命名为ccSAFDlg，在ccSAFDlg.ui文件设计简单的界面。 因为我们只需要一个范围，一个确认取消键，所以我把它弄成这样子： doubleSpinBox要设置范围：0.00到90.00，默认值分别设为20.00和70.00。 ccSAFDlg.h： #ifndef CCSAFDLG_H #define CCSAFDLG_H #include &quot;ui_SAFDlg.h&quot; #include &lt;QDialog&gt; namespace Ui { class ccSAFDlg; } class ccSAFDlg : public QDialog, public Ui::ccSAFDlg { Q_OBJECT public: explicit ccSAFDlg(QWidget *parent = 0); protected slots: //! Saves (temporarily) the dialog paramters on acceptation void saveSettings(); }; #endif // CCSAFDLG_H ccSAFDlg.cpp： #include &quot;ccSAFDlg.h&quot; //定义两个静态阈值，并初始化 static double threshold_1 = 20; static double threshold_2 = 70; ccSAFDlg::ccSAFDlg(QWidget *parent) : QDialog(parent), Ui::ccSAFDlg() { setupUi(this); //关联信号槽 connect(buttonBox, SIGNAL(accepted()), this, SLOT(saveSettings())); //初始化设置阈值 doubleSpinBox_1-&gt;setValue(threshold_1); doubleSpinBox_2-&gt;setValue(threshold_2); } void ccSAFDlg::saveSettings() { //OK后重新赋值 threshold_1 = doubleSpinBox_1-&gt;value(); threshold_2 = doubleSpinBox_2-&gt;value(); } 现在界面就做好了。 插件doAction实现至于doAction的实现，点云其中的数据结构，可以参考第二篇，数据结构篇 简单地说，我们需要： 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 大体的算法思路上是没有问题的，但是有个纠结的地方，就是是否使用进度条。 实测SAF处理一个雷达文件， 使用进度条耗时：129.1s 不用进度条耗时：3.5s 这种压倒性的差距让我果断砍掉真·进度条，没错！我使用假·进度条，就是不会动的进度条。 这样短时间的处理使用假·进度条，既不会降低处理速度，也不会降低用户体验~ 下面就是完整代码，注释中有真·进度条的实现（[进度条]），但不推荐使用 void qSAF::doAction() { //当插件加载时，m_app应该已经被CC初始化了 assert(m_app); if (!m_app) return; //获取选择的实体 const ccHObject::Container&amp; selectedEntities = m_app-&gt;getSelectedEntities(); //获取选择的实体数量 size_t selNum = selectedEntities.size(); //确保只选择一个实体 if (selNum != 1) { m_app-&gt;dispToConsole(&quot;[SAF] Select only one cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } ccHObject* ent = selectedEntities[0]; assert(ent); //确保选择的实体是POINT_CLOUD类型 if (!ent || !ent-&gt;isA(CC_TYPES::POINT_CLOUD)) { m_app-&gt;dispToConsole(&quot;[SAF] Select a real point cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //从选择的实体中转换成ccPointCloud*类型 ccPointCloud* pc = static_cast&lt;ccPointCloud*&gt;(ent); //获取点云的数量m_count unsigned count = pc-&gt;size(); //初始化阈值变量 static double threshold_1 = 20; static double threshold_2 = 70; double threshold_temp = 0; //显示插件ui窗体 { ccSAFDlg safDlg(m_app-&gt;getMainWindow()); safDlg.doubleSpinBox_1-&gt;setValue(threshold_1); safDlg.doubleSpinBox_2-&gt;setValue(threshold_2); if(!safDlg.exec()) { return; } //存储阈值 threshold_1 = safDlg.doubleSpinBox_1-&gt;value(); threshold_2 = safDlg.doubleSpinBox_2-&gt;value(); } //显示进度条窗体 QProgressDialog pDlg; pDlg.setWindowTitle(&quot;SAF&quot;); pDlg.setLabelText(QString(&quot;Scan Angle Filter\nfrom %1 to %2&quot;).arg(threshold_1).arg(threshold_2)); //[进度条]设置进度条总范围 //pDlg.setRange(0, count); pDlg.setCancelButton(0); pDlg.show(); QApplication::processEvents(); QElapsedTimer timer; //计时开始 timer.start(); ScalarType scanAngle; CCLib::ReferenceCloud rangeAnglerc(pc); //确保 threshold_1 小于 threshold_2 if(threshold_1 &gt; threshold_2) { threshold_temp = threshold_1; threshold_1 = threshold_2; threshold_2 = threshold_temp; } //[进度条]进度条的取消SAF按钮 //bool wasCancelled = false; //获取 Scan Angle Rank 的索引 int scanAngleSFIndex = pc-&gt;getScalarFieldIndexByName(&quot;Scan Angle Rank&quot;); //[重点]遍历每个点的操作 for(unsigned i = 0; i &lt; count; ++i) { //获取每个点的扫描角度 scanAngle = pc-&gt;getScalarField(scanAngleSFIndex)-&gt;getValue(i); //取扫描角度的绝对值 if(scanAngle &lt; 0) { scanAngle = -scanAngle; } //如果扫描角度在给定的阈值范围，则添加它的索引到参考云 if(threshold_1 &lt;= scanAngle &amp;&amp; scanAngle &lt;= threshold_2) { rangeAnglerc.addPointIndex(i); } // //[进度条]重置进度条 // pDlg.setValue(i); // QCoreApplication::processEvents(); // //[进度条]取消SAF处理 // if (pDlg.wasCanceled()) // { // wasCancelled = true; // break; // } } //把 ReferenceCloud 类型克隆成 ccPointCloud 类型 ccPointCloud* rangeAnglepc = pc-&gt;partialClone(&amp;rangeAnglerc); //判断rangeAnglepc是否为空，即所选范围内是否有点 if(!rangeAnglepc) { m_app-&gt;dispToConsole(&quot;[SAF] Failed to extract the range angle subset.&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //计算SAF后点数所占的百分比和SAF过程所花的时间 m_app-&gt;dispToConsole(QString(&quot;[SAF] %1% of scan angle points are filtered&quot;).arg((rangeAnglerc.size() * 100.0) / count, 0, &apos;f&apos;, 2), ccMainAppInterface::STD_CONSOLE_MESSAGE); m_app-&gt;dispToConsole(QString(&quot;[SAF] Timing: %1 s.&quot;).arg(timer.elapsed() / 1000.0, 0, &apos;f&apos;, 1), ccMainAppInterface::STD_CONSOLE_MESSAGE); //关闭进度条 pDlg.close(); QApplication::processEvents(); // //[进度条]取消SAF // if (wasCancelled) // { // m_app-&gt;dispToConsole(&quot;[SAF] SAF was cancelled&quot;, ccMainAppInterface::STD_CONSOLE_MESSAGE); // return; // } //隐藏原始点云 pc-&gt;setEnabled(false); //添加新的一组DB实体 ccHObject* cloudContainer = new ccHObject(pc-&gt;getName() + QString(&quot;_saf&quot;)); //设置新点云并添加到实体 rangeAnglepc-&gt;setVisible(true); rangeAnglepc-&gt;setName(&quot;SAF Point Cloud&quot;); cloudContainer-&gt;addChild(rangeAnglepc); //添加实体到DB树 m_app-&gt;addToDB(cloudContainer); //刷新 m_app-&gt;refreshAll(); } 效果 结语经过了三篇的学习，终于实现了个完整的插件。 回顾我们学习的路线：插件框架 -&gt; 数据结构 -&gt; 算法实现 我们不仅从中学会了CC插件的编写，也学到了QT的pro文件编写、QT界面设计、CC运作流程、点云数据结构等。 而我在学习这个插件编写的过程收获更多，因为我是看代码两个月，写代码两小时，Debug两天（差不多啦~不要纠结为什么222~） 看代码的过程是非常痛苦的，CC里面大量的模板编程思想，接口设计思想，还有去他继承谁爸爸的爸爸…… 但是期间确实学到很多，以此作为分享，望共勉！]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT的pro文件编写]]></title>
    <url>%2F2017%2F04%2F26%2FQTProFile%2F</url>
    <content type="text"><![CDATA[常规pro文件下面是CloudCompare中一个自己写的插件的pro文件， pro文件编写可按照如下方式写。 # 添加QT的模块 QT += widgets \ opengl # 指明让qmake生成哪种makefile文件，app表示应用程序，lib表示库 TEMPLATE = lib # 指明生成的库的名字 TARGET = qSAF # 指明编译依赖路径 DEPENDPATH += .\ # 包含头文件路径 INCLUDEPATH += .\ $$PWD/../ # 工程的头文件路径 HEADERS += qSAF.h \ ../ccStdPluginInterface.h \ ../ccPluginInterface.h \ ../ccMainAppInterface.h \ ccSAFDlg.h # 工程的源文件路径 SOURCES += qSAF.cpp ../ccStdPluginInterface.cpp \ ccSAFDlg.cpp # 工程的资源文件路径 RESOURCES += qSAF.qrc #CC (CloudCompare核心算法库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB # 包含CC的头文件路径 INCLUDEPATH += $$PWD/../../CC/include # 包含CC的依赖路径 DEPENDPATH += $$PWD/../../CC #qCC_db (CloudCompare数据库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB INCLUDEPATH += $$PWD/../../libs/qCC_db DEPENDPATH += $$PWD/../../libs/qCC_db # 工程的ui文件路径 FORMS += \ SAFDlg.ui # Mac系统下，则执行括号内的代码 macx { # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../../Release/libs -Wl #指定生成路径 DESTDIR = $$PWD/../../../Release/CloudCompare.app/Contents/plugins } # Mac外的其他Unix系统下(Linux)，则执行括号内的代码 unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic #指定生成路径 DESTDIR = $$PWD/../../../Release/plugins } # Windows系统下，则执行括号内的代码 win32 { # windows only }]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ IO 库条件状态及EOF]]></title>
    <url>%2F2017%2F04%2F15%2FCppConditionStateAndEOF%2F</url>
    <content type="text"><![CDATA[文本文件判空问题对于空文本文件的判断问题引起了我对 IO 库中条件状态和 EOF 的探究。 就是这段程序： int vehicle_number; fstream infile; infile.open(&quot;vehicle.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; vehicle_number; ...... } infile.close(); } 它可以打开空文本文件并运行到 while(!infile.eof()) 循环里面。由于是空文本文件，它进入里面会造成一些问题，所以需要对文件进行判空。 EOFEOF（End Of File） 常用于： 文件结束标志 函数出错的返回值 在 C++ IO 库中可用作： 条件状态的判定 现在让我们看看 IO 库中的描述。 IO 库条件状态【表一】IO 库条件状态 状态 含义 strm::iostate strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能 strm::badbit strm::badbit用来指出流已崩溃 strm::failbit strm::failbit用来指出一个IO操作失败了 strm::eofbit strm::eofbit用来指出流达到了文件结束 strm::goodbit strm::goodbit用来指出流未处于错误状态。此值保证为零 s.eof() 流 s 的 eofbit 置位，则返回 true s.fail() 流 s 的 failbit 或 badbit 置位，则返回 true s.bad() 流 s 的 badbit 置位，则返回 true s.good() 若流 s 处于有效状态，则返回 true s.clear() 将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void s.clear(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是strm::iostate。返回 void s.setstate(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void s.rdstate() 返回流 s 的当前条件，返回值类型为 strm::iostate 【表二】四种条件状态 状态 含义 数值 good() eof() bad() fail() rdstate() ios::goodbit 流状态完全正常 0 1 0 0 0 goodbit ios::eofbit 已达到文件结束 2 0 1 0 0 eofbit ios::badbit 输入（输出）流出现非致命错误，可挽回 1 0 0 1 0 badbit ios::failbit 输入（输出）流出现致命错误，不可挽回 4 0 0 0 1 failbit 我们先看【表一】的关于 EOF 的这两行： 状态 解释 strm::eofbit strm::eofbit用来指出流达到了文件结束 s.eof() 流 s 的 eofbit 置位，则返回 true 这里指出当流读到文件结束时，eofbit 置 1 ，用于标识读取到文件的末尾。 而 eof() 是当 eofbit 置位（置 1）时才返回，并不是读到文件末尾就返回。 所以使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 文本文件判空问题的解释现在就可以解释最初的问题了，让我们回过头看看。 当程序第一次运行到 while(!infile.eof()) 时，infile.eof() 读到文件末尾的 EOF，但并不是立刻返回 true，只是 eofbit 置位，所以 infile.eof() 还是 false 的状态，所以会进入 while 循环。 文本文件判空问题的解决 把流对象状态当做条件使用 if(infile.is_open()) { while(infile &gt;&gt; vehicle_number) { ...... } } 使用 peek() istream::peek() 用于读取并返回流的下一个字符（返回值为 char 类型），但并不读取该字符到输入流中，即流指针依然指向原来位置，并不后移。 if(infile.is_open()) { while(infile.peek() != EOF) { infile &gt;&gt; vehicle_number; ...... } } 重复读入非空文本文件最后一个字符问题经过上面的解释，我们已经知道了文本文件如何判空。但由于 EOF 的锅，若用 while(!infile.eof()) 还会导致重复读入非空文本文件最后一个字符的问题。 看下面这段代码： char c; fstream infile; infile.open(&quot;test.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; c; cout &lt;&lt; c; } } infile.close(); 和文本文件判空问题的代码相似，只是读入字符存储到 char 类型变量中，并把其输出。 然后我们在 test.txt 中保存 abc 这三个字符。 运行的结果是： abcc 即 while(!infile.eof()) 重复执行了最后一趟，多输入了字符 c 。 这个问题和文本文件判空问题的解决办法一样，都是使用 peek() 或者把流对象当做 while 的条件来解决。 总结 使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 只有一个流处于无错状态时，我们才可以对它读写数据。因此代码通常应该在使用一个流之前检查它是否处于良好状态。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 7 挂载 NTFS 分区]]></title>
    <url>%2F2017%2F03%2F29%2FCentos7NTFS%2F</url>
    <content type="text"><![CDATA[NTFS-3G安装使用 NTFS-3G 实现，可以挂载 NTFS，还可以挂载 HFS+ 等，以下是在 Centos 7 下安装 NTFS-3G 及挂载 NTFS 分区 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo sudo yum update sudo yum install ntfs-3g 查看分区fdisk -l 挂载# d、e、f改成你想要挂的盘符名字 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f # d、e、f改成你想要挂的盘符名字，sdb3这些改为要挂的分区 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d mount -t ntfs-3g /dev/sdb4 /mnt/windows/e mount -t ntfs-3g /dev/sdb5 /mnt/windows/f 卸载umount /mnt 设置开机自动挂载sudo vim /etc/fstab #只读式挂载： /dev/sda1 /mnt/windows/c ntfs-3g ro,umask=0222,defaults 0 0 #读写式挂载： /dev/sda1 /mnt/windows/c ntfs-3g rw,umask=0000,defaults 0 0 #或者： /dev/sda1 /mnt/windows/c ntfs-3g defaults 0 0 设置后开机无法启动（无法挂载）网上很多教程都是如上几步就好了~ 然而我的无法开机。 如下图： 这样应该需要输入root密码，用root账户登录修复模式， 然后 vim /etc/fstab 删除刚刚添加的东西， reboot 就能进入系统了 所以之前之前忙活的都没用了？ 后来试了下原来 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d 这句本身就无法挂载！ 然后可以通过 sudo mount -o ro /dev/sdb3 /mnt/windows/d 挂载，但是只能通过终端访问，就是下面这个👇 其他问题无法挂载的解决办法实现了只能在终端访问 #创建挂载点 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f #挂载分区 sudo mount -o ro /dev/sdb3 /mnt/windows/d sudo mount -o ro /dev/sdb4 /mnt/windows/e sudo mount -o ro /dev/sdb5 /mnt/windows/f #添加上面挂载分区到这里面 sudo vim /etc/rc.d/rc.local #更改权限 chmod +x /etc/rc.d/rc.local Thankshttp://www.cnblogs.com/gbyukg/archive/2011/11/02/2232343.html http://www.jianshu.com/p/f578b575fcaa http://askubuntu.com/questions/462381/cant-mount-ntfs-drive-the-disk-contains-an-unclean-file-system https://www.techbrown.com/mount-ntfs-file-system-centos-7-rhel-7.shtml]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下QT编译输出路径错误：ld unknown option ...]]></title>
    <url>%2F2017%2F03%2F26%2FMacQTCompilerOutputPathError%2F</url>
    <content type="text"><![CDATA[ERROR: ld unknown option rpathMac指定qmake的生成路径时，用 -Wl,-rpath,$$PWD/.. 而不是 -Wl,-rpath=$$PWD/.. 如下： macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../Release/libs -Wl # 指定生成路径 DESTDIR = $$PWD/../../Release } Linux则用 -Wl,-rpath=$$PWD/.. unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic # 指定生成路径 DESTDIR = $$PWD/../../Release/libs } ERROR: ld unknown option BsymbolicMac 不支持-Bsymbolic，所以不能这样： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl,-Bsymbolic 应该删去-Bsymbolic，如下： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks-Qt5 For Centos 7]]></title>
    <url>%2F2017%2F03%2F25%2FShadowsocks-Qt5ForCentos7%2F</url>
    <content type="text"><![CDATA[Preface Shadowsocks client without GUI tutorial: Linux安装配置Shadowsocks客户端及开机自动启动 Shadowsocks-Qt5 client tutorial: Shadowsocks-Qt5 For Centos 7 Shadowsocks server tutorial: 搬瓦工Shadowsocks安装及配置多用户(服务端) InstallIf you use the traditional yum package management tool, you need to download the appropriate version of the repo file from the Copr to /etc/yum.repos.d/, and then install through yum. As follows: # Centos 7 wget https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-7/librehat-shadowsocks-epel-7.repo sudo mv librehat-shadowsocks-epel-7.repo /etc/yum.repos.d/ sudo yum update sudo yum install -y shadowsocks-qt5 Config Explanation of the fields: Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb”, see Encryption fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux ProxyGo to Settings-Network-Network proxy, turn on proxy. Use the sock proxy local_address: the address your local listens (default:1080) local_port: local portocal (default:127.0.0.1) Have fun!]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare功能概要]]></title>
    <url>%2F2017%2F03%2F21%2FCloudCompareFunction%2F</url>
    <content type="text"><![CDATA[File open：打开 save：保存 Global Shift settings：设置最大绝对坐标，最大实体对角线 Primitive Factory：对点云进行原始加工，改变原始点云的形状 3D mouse：对3D鼠标（如3Dconnexion）的支持 Close all：关闭所有打开的实体 Quit：退出 Edit： Clone：克隆选中的点云 Merge：合并两个或者多个实体。可以合并点云（原始云会被删除）；可以合并网格（原始网不会修改，CC会创建一个新的网格结构） Subsample：采集原始点云的子样本，可以用随机、立体、基于八叉树的方式采集，子样本会保持原始点云的标量、颜色、法线等性质。 Apply Transformation：可以对选中的实体做变换（4*4矩阵、轴线角，欧拉角） Multiply / Scale：让选中实体的坐标倍增。 Translate / Rotate (Interactive Transformation Tool)：可以相对于另外一个实体或者坐标系移动选中的实体 Segment (Interactive Segmentation Tool)：通过画2D多边形分隔选中的实体 Crop：分割一个或多个在3D-Box里面的点云。 Edit global shift and scale：进行全局变换和和比例缩放。 Toggle (recursive)：用于控制键盘的快捷键。 Delete：删除选中的实体。 Colors &gt; Set Unique：为所选实体设置唯一一个的颜色 Colors &gt; Colorize：为所选实体着色，具体表现为分别用所选颜色乘以当前颜色的RGB而得到新的颜色 Colors &gt; Levels：通过调整颜色的柱形图变色，类似于Photoshop的Levels方法 Colors &gt; Height Ramp：为所选实体设置颜色渐变（线形、梯形、环形） Colors &gt; Convert to Scalar Field：将当前的 RGB 颜色字段转换为一个或几个标量字段 Colors &gt; Interpolate from another entity：在所选实体中插入另外一个实体的颜色 Colors &gt; Clear：移除所选实体的颜色域 Normals &gt; Compute：计算所选实体的法线 Normals &gt; Invert：反转所选实体的法线 Normals &gt; Orient Normals &gt; With Minimum Spanning Tree：用同样的方法重新定位点云的全部法线（最小生成树） Normals &gt; Orient Normals &gt; With Fast Marching：用同样的方法重新定位点云的全部法线（快速行进法） Normals &gt; Convert to &gt; HSV：将云的法线转换到 HSV 颜色字段 Normals &gt; Convert to &gt; Dip and Dip direction SFs：转换点云的法线到两个标量域 Normals &gt; Clear：为选定的实体移除法线 Octree &gt; Compute：强制计算给定实体的八叉树 Octree &gt; Resample：通过代替每个八叉树单元内的所有点来重新取样 Mesh &gt; Delaunay 2.5D (XY plane)：计算点云在xy平面上的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Delaunay 2.5D (best fit plane)：计算点云在最佳平面的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Convert texture/material to RGB：将选定网格的网格材料和纹理信息转换为逐个点的 RGB 字段 Mesh &gt; Sample points：在一个网格中随机取样 Mesh &gt; Smooth (Laplacian)：平滑一个网格（Laplacian smoothing，拉普拉斯平滑算法） Mesh &gt; Subdivide：细分网格，此算法递归细分网格三角形，直到他们的表面细分到用户指定值之下。 Mesh &gt; Measure surface：测量网格的总体表面积和每个三角形的平均表面积，在控制台输出 Mesh &gt; Measure volume：测量闭合网格的体积，在控制台输出 Mesh &gt; Flag vertices：检查网格的基本特性，为每个网格样本做标志：0 = normal，1 = border，2 = non-manifold Mesh &gt; Scalar field &gt; Smooth：平滑网格顶点相关联的标量场。此方法与高斯滤波（Gaussian Filter）相反。运用qPCV插件后，此方法特别有用 Mesh &gt; Scalar field &gt; Enhance：增强与网格顶点相关联的标量场。运用qPCV插件后，此方法特别有用 Sensors &gt; Edit：修改指定传感器内外在参数 Sensors &gt; Ground Based Lidar &gt; Create：创建’Ground Based Lidar’ (= TLS)传感器实体，附加到所选的点云 Sensors &gt; Ground Based Lidar &gt; Show Depth Buffer：显示选中的Ground Based Lidar的深度 Sensors &gt; Ground Based Lidar &gt; Export Depth Buffer：以ASCII文件的形式导出选中的Ground Based Lidar传感器的深度图 Sensors &gt; Camera Sensor &gt; Create：创建影像传感器 Sensors &gt; Camera Sensor &gt; Project uncertainty：输出影像模块不确定的点云，输出不确定的x、y、z、3D信息 Sensors &gt; Camera Sensor &gt; Compute points visibility (with octree)：统计选中影像传感器选中的点云。0=NOT VISIBLE，1=VISIBLE Sensors &gt; View from sensor：更改当前的 3D 视图影像设置以匹配选定的传感器的设置 （用泡沫视图模式） Sensors &gt; Compute ranges：计算全部点（对于任何点云）相对于指定传感器的范围 Sensors &gt; Compute scattering angles：计算全部点（对于任何有法线的云）相对于选中传感器分散的角度 Scalar fields &gt; Show histogram：对当前选中的实体显示有效标量域的柱形图 Scalar fields &gt; Compute statistical parameters：计算统计分布（高斯分布、威布尔分布） Scalar fields &gt; Gradient：计算标量域的梯度 Scalar fields &gt; Gaussian filter：通过应用一个立体高斯滤镜，平滑一个标量域 Scalar fields &gt; Bilateral filter：用双边滤镜平滑一个标量域 Scalar fields &gt; Filter by Value：用标量值筛选选定的云 Scalar fields &gt; Convert to RGB：将有效的标量场转化为RGB颜色域 Scalar fields &gt; Convert to random RGB：将有效的标量场转化为随机的RGB颜色域 Scalar fields &gt; Rename：对选中实体重命名有效的标量域 Scalar fields &gt; Add constant SF：用一个常数添加一个标量域 Scalar fields &gt; Add point indexes as SF：用点索引的方式为所选点云创建一个新的标量域 Scalar fields &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Scalar fields &gt; Set SF as coordinate(s)：为选中的点云设置标量域的坐标 Scalar fields &gt; Arithmetic：可以对在同一个点云的两个标量域进行标准运算（+，-，*，/），或者对单个标量域进行函数运算 Scalar fields &gt; Color Scales Manager：色阶管理，可以管理和创建新色域 Scalar fields &gt; Delete：对选中的实体删除有效的标量域 Scalar fields &gt; Delete all (!)：对选中的实体删除全部的有效标量域 Tools： Level：可以选择三个点确定一个平面来操作 Point picking：可以选择一个、两个、三个点来得到各种信息，如点的坐标、RGB、标量值、距离、角度等信息（尤其是两点间的距离） Point list picking：可以选择多个点创建一个点列表，可以输出为一个文件、一个新点云、一个折线 Clean &gt; Noise filter：类似于qPCL插件的S.O.R.滤镜，但又更多功能 Projection &gt; Unroll：展开圆柱或圆锥体的点云成一个平面 Projection &gt; Rasterize：栅格化点云（转化为2.5D网格），然后可以导出为一个新点云或者一个光栅图像 Projection &gt; Contour plot to mesh：可以把一组折线转化为网格，输出边缘轮廓线 Projection &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Registration &gt; Match bounding-box centers：调整所有选中的实体，让它们的中心在一个地方 Registration &gt; Match scales：匹配所有选中实体的规模 Registration &gt; Align (point pairs picking)：在两个实体中挑选至少三个对应的点来对齐两个实体 Registration &gt; Fine registration (ICP)：自动精确地融合两个实体。前提是：①两个云大体上相融；②表现为同样的对象或者至少有同样的形状 Distances &gt; Cloud/Cloud dist. (cloud-to-cloud distance)：计算两个点云之间的距离 Distances &gt; Cloud/Mesh dist. (cloud-to-mesh distance)：计算点云和网格之间的距离 Distances &gt; Closest Point Set：计算两个点云之间最近的点的集合 Statistics &gt; Local Statistical Test：可以以标量域的局部统计为基础进行分割和过滤点云 Statistics &gt; Compute Stat. Params：计算统计分布（高斯分布、威布尔分布） Segmentation &gt; Label Connected Components：设置最小距离，把所选的云分割成更小的部分，每一部分相互连接 Segmentation &gt; Cross Section：用户可以定义一个裁剪框，可调整框的范围和方向，来裁剪点云。可以用来：①在一个或多个维度重复分割过程；②获取多边形的轮廓 Segmentation &gt; Extract Sections：可以在一个点云的顶部画或者导入多边形来提取截面和轮廓 Fit &gt; Plane：匹配点云中的一个平面和输出各种信息，如拟合 RMS、 垂直平面、地质的倾角、倾角方向值等 Fit &gt; Sphere：适配点云中的一个球体 Fit &gt; 2D Polygon：适配点云中的二维多边形 Fit &gt; Quadric：适配点云中的2.5D曲面 Other &gt; Density：估量一个点云的密度 Other &gt; Curvature：估量一个点云的曲率 Other &gt; Roughness：估量一个点云的粗糙程度 Other &gt; Remove duplicate points：通过设置两点之间最小距离来删除重复的点 Display： Full screen：全屏 Refresh：刷新，强制刷新有效的3D视图的内容（OpenGL图形重绘） Toggle Centered Perspective：在正交视图和对象中心视图模式中切换 Toggle Viewer Based Perspective：在正交视图和透视图中切换 Lock rotation about vert. axis：锁定围绕Z轴的影像旋转 Enter bubble-view mode：进入泡沫视图模式 Render to File：可以渲染当前的3D视图成一个图像文件（支持多数标准文件格式），还可以缩放以适应更大分辨率的屏幕 Display settings：对各种显示进行设置：颜色和材质、色阶、标签、其他 Camera settings：影像设置 Save viewport as object：保存当前3D视图的可视体的参数（影像位置和方、透视状态）为一个可视实体，这个实体自动地添加DB树的根 Adjust zoom：调整缩放比例 Test Frame Rate：测试帧速率，让有效的3D视图在一个较短时间旋转从而估量平均帧数，结果在控制台显示 Lights &gt; Toggle Sun Light：切换太阳光 Lights &gt; Toggle Custom Light：切换自定义的光 Shaders and Filters &gt; Remove filter：禁用任何活动的着色器或者OpenGL过滤器 Active scalar field &gt; Toggle color scale：为所选活动的实体切换色阶 Active scalar field &gt; Show previous SF：改变当前所选对象的标量域，激活先前的标量域 Active scalar field &gt; Show next SF：改变当前所选对象的标量域，激活下一个的标量域 Console：控制台（显示/隐藏） Toolbars：工具栏，包括主工具栏、标量域、视图、插件、GL滤镜 Reset all GUI elements：退出钱自动存储当前GUI信息（位置和工具栏的可见性等），可以恢复原始配置 Plugins：Standard plugins： qHPR (Hidden Point Removal)：如果点云是闭合曲面，则可以过滤（删除）掉通过当前3D影像不能看到的云 qPCL (Point Cloud Library Wrapper)：有PCL库一些方法的接口，主要包括：①计算法线和曲率②异常点和噪声点的去除③平滑点云（移动最小二乘法） qPCV (ShadeVis / Ambient Occlusion)：计算点云的明亮度，类似于光线来自于对象周围的半球或球体（可以自定义光线距离） qPoissonRecon (Poisson Surface Reconstruction)：Poisson表面重建，用三角网络生成算法构建的简单的表面 qRansacSD (RANSAC Shape Detection)：随机抽样一致形状检测，运用自动形状检测算法的简单接口 qSRA (Surface of Revolution Analysis)：计算一个点云和一个假定旋转平面之间的距离（旋转平面用2D轮廓定义），距离计算好后，用户可以创建一个偏差的2D图或者圆柱或圆锥的投影 qCANUPO (Point Cloud Classification)：可自动对点云进行分类，也可以手动分类 qM3C2 (Robust C2C Distances Computation)：用独特的方法计算两个点云之间的有向（稳健）距离 qCork (Boolean Operations on Meshes)：可以执行网格中的布尔操作（也称CSG = 构造实体几何），它基于Cork库 qAnimation：动画渲染插件 qFacets：可以从点云中自动提取二维切面，以它们的垂直距离分开 qCSF (Cloth Simulation Filter)：基于布模拟滤波算法，能实现地面点与非地面点的分离，去除非地面点 qCompass：简单地实现点云中地质结构的它的轨迹的数字化 qBroom (qVirtualBroom)：高效地扫描和清理 qHoughNormals：计算法法线 qGMMREG：对小型实体的非刚性云的匹配 qLAS_FWF：这个插件可以读写标准雷达文件，可以在命令模式下打开LAS 1.3+文件 qPoissonRecon：可以让输入的点云颜色映射到成网格（快速直接地分配到颜色接近输入点颜色的网格顶点） OpenGL ‘shaders’ plugins： qEDL (Eye Dome Lighting)：实时底纹滤镜，用来在空白的点云或者网格中增强少量特质（除了几何信息外，它不依赖于其他信息） qSSAO (Screen Space Ambient Occlusion)：实时底纹滤镜，与环境相似的遮挡 qBlur：一个简单的模糊处理滤镜，主要用于开发人员的演示 Deprecated qKinect (Point Cloud Acquisition with a Kinect)：可以用Kinect设备获取（有色的）点云 3D Views： New：创建3D视图 Close：关闭3D视图 Close All：关闭所有3D视图 Tile：共享的所有 3D 视图之间的显示空间 Cascade：用串联的方式重新排列所有 3D 视图 Next：激活顺序创建的下一个3D视图 Previous：激活顺序创建的上一个3D视图 Help： Help：帮助文档 About：CloudCompare版本信息 About Plugins：插件信息 Thanks： CloudCompare Documentation CloudCompare Wiki Wikipedia]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile 问题及解决]]></title>
    <url>%2F2017%2F03%2F13%2FMakefileIssue%2F</url>
    <content type="text"><![CDATA[问题一makefile文件的clean出错 解决clean下面的那句命令没有缩进，应该用[Tab]缩进 小结 利用 Google、stackoverflow 等含金量高的问题解决平台 注意语法规范 问题二 解决newhello:hello.o hello_fn.o 中的newhello应该写成hello，应该与hello.c中的名字一样 小结 注意编译运行的文件名]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2 + OhMyZsh + agnoster + Powerline + solarized = 漂亮的Mac终端]]></title>
    <url>%2F2017%2F03%2F11%2FFancyMacTerminal%2F</url>
    <content type="text"><![CDATA[唠叨一下自从装了黑苹果后一直用着 Mac 自带的终端（Terminal），相比 Windows 的终端根本无法同台竞技！毕竟 Mac 是基于 Unix 嘛~ 对开发友好太多了。 就是下面这个家伙了👇 本来没觉得什么，直到我看到它👇 颜值碾压，有木有！ 所以就着手折腾了…… iTerm2iTerm是一个非常好的终端模拟器，官网地址：http://iterm2.com/，需要下载它。 zshzsh 是一款强大的虚拟终端，是 Oh My Zsh 的爸爸，所以需要先装它。 在命令行输入： zsh --version 如果输入zsh的当前版本号就说明装好了，一般Mac自带有的 如果没装则需要输入： brew install zsh zsh-completions 这是用Homebrew装，需要Mac上有Homebrew，它的网站：https://brew.sh/ Oh My ZshOh My Zsh 是基于 zsh 的一个扩展工具集，它提供了丰富的扩展功能 它可以通过curl或者wget来安装 via curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 装好之后就可以换到 agnoster 主题，就是之前看到的那张颜值主题，Oh My Zsh 一般自带有这个主题。 可以看看它的默认主题： ls ~/.oh-my-zsh/themes 需要修改主题只需： vim ~/.zshrc 然后把里面 ZSH_THEME 的值改为 ZSH_THEME=&quot;agnoster&quot;，保存退出 （点击这里还有各种主题，任君翻牌~） 应用配置： chsh -s /bin/zsh 重启 iTerm2 然后你会惊喜地发现…… 和颜值主题并不一样！ 难道官方坑爹？ 震惊！oh-my-zsh 竟然做出这种事！ 嘛~ 原来少了 Powerline 的字符集 PowerlineGit 下来安装： git clone git@github.com:powerline/fonts.git cd fonts ./install.sh 然后到 iterm2 配置，设置字体为Roboto Mono for Powerline： 这样就可以有颜值图的效果了~ 然而终端下的 vim 编辑器还是一种颜色~ 作为一个追求完美的 geek 怎能容许此等瑕疵呢！ 所以就继续捣鼓 solarized 配色。 solarizedSolarized 是个很牛逼的配色项目，主流OS、IDE、Editor都有它影子。 # git下Solarized 的源码 git clone git://github.com/altercation/solarized.git # 进入文件夹 cd solarized/vim-colors-solarized/colors #下面可能要管理员权限 sudo mkdir -p ~/.vim/colors sudo cp solarized.vim ~/.vim/colors/ # 创建.vimrc文件 sudo vim ~/.vimrc # 把下面这三行复制进去 syntax enable set background=dark colorscheme solarized 然后保存 .vimrc, 退出 之后打开用 vim 打开文件就是这种效果了： Thanks iTerm2 robbyrussell/oh-my-zsh powerline/fonts altercation/solarized]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简易入门教程]]></title>
    <url>%2F2017%2F01%2F25%2FMarkdownTutorial%2F</url>
    <content type="text"><![CDATA[自己整理的 Markdown 简介、编辑器推荐、语法、特征等，是 Markdown 的简易入门教程 目录 概述 简介 官方文档 Markdown编辑器 初级语法 标题 粗体和斜体 段落和换行 分隔线 引言 列表 无序列表 有序列表 代码 行内代码块 段落代码块 链接 网址链接 图片链接 指定图片宽高 用图床获取外链 进阶语法 标签 目录 表格 脚注 公式 流程图 序列图 其他 兼容HTML 特殊字符自动转换 反斜杠 自动链接 感谢 概述 简介 Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：WordPress、Drupal、简书等。 官方文档 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown编辑器 在线编辑器 dillinger——漂亮强大，支持md, html, pdf 文件导出。 简书——非常漂亮的博客平台，可以自动备份，直接拖入图片。 Windows MarkdownPad——一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 MarkPad——开源软件，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。 Cmd Markdown——作业部落出品，全平台并支持Web端 Mac Mou——简洁优雅，免费又好用，中文兼容性好。 Typora——极致简洁，自定义皮肤。 MacDown——简洁优雅，开源免费。 Ulysses——文字写作推荐。 多平台 Atom——github出的编辑器，支持各种编程语言，可装Markdown插件。 sublimetext——专业编辑器，支持各种编程语言。 初级语法 标题 Markdown 支持两种标题的语法，类 Atx 和类 Setext 形式。 Atx（注意#后面有个空格） # 一级标题 ## 二级标题 ### 三级标题 Setext（-与=数目任意，最好三个及以上，比较直观） 一级标题 ====== 二级标题 ------ 粗体和斜体 粗体 **这是粗体** __这是粗体__ 斜体 *这是斜体* _这是斜体_ 段落和换行 第一种写法（上图的这是第一段），直接敲两个回车键即可 这是第一段 这是第二段 第二种写法（上图的这是第二段），在写完一段后敲两个空格，然后回车写下一段 这是第二段 这是第三段 第三种写法（上图的这是第三段），在写完一段后用HTML的语法：&lt;br /&gt;作为换行，然后写下一段 这是第三段&lt;br /&gt;这是第四段 这是第三段&lt;br /&gt; 这是第四段 分隔线 可以在一行中用三个及以上的星号、减号、等于号、底线来建立分隔线，行内不能有除空格外的其他东西，注意莫被打脸。 (≖ ‿ ≖)✧ *** --- === ___ 引言 &gt; 我想只用一个 “&gt;” 号来写一个多行的引用，所以在扯鸡巴蛋地码字占空间，好像差不多了吧，嗯嗯~ --- &gt; 还有一种写法就是每一行都用一个 “&gt;” 号 &gt; 这样写比较美观一点 --- &gt; &gt; 另外一种就是嵌套引用，就像我一样，用两个“&gt;” 列表 无序列表 无序列表可以在每行开头用星号、加号、减号来表示，也可以三者混合一起，推荐使用相同的字符，避免混乱。 * 一朵百合花 * 两朵百合花 * 三朵百合花 有序列表 有序列表用数字接着一个英文句点来表示，数字可无序，但还是推荐使用1.、2.，避免混乱。 1. 一朵百合花 2. 两朵百合花 3. 三朵百合花 代码 行内代码块 I am a `code` I am a `` ` `` 段落代码块 #### 第一种 int main() { printf(&quot;我是个段落代码块&quot;); return 0; } 另外，可以用三个反引号和语言名，作为标记代码所使用的语言 我的 Mou 编辑器不能识别 (ノ▼Д▼)ノ 链接 网址链接 网址链接有两种形式：行内式、参考式。 不管是哪一种，链接文字都是用 [方括号] 来标记，双引号&quot;&quot;的title可写可不写。 行内式 [huihut](https://huihut.github.io/) [huihut](https://huihut.github.io/ &quot;huihut&quot;) [huihut](https://huihut.github.io/ &apos;huihut&apos;) 参考式 一般写法 [huihut][1] [1]: https://huihut.github.io/ 隐式链接标记——可省略id，只需要[text]与下面[方括号]内容相同即可 [Google][] [Google]: http://google.com/ 拓展 这里的链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [text][a] [text][A] 链接 title 可以用双引号、单引号、圆括号包起来，因此，下面这三种链接的定义都是相同： [1]: https://huihut.github.io/ &quot;title&quot; [1]: https://huihut.github.io/ &apos;title&apos; [1]: https://huihut.github.io/ (title) 特别注意：Markdown.pl 1.0.1 会忽略单引号包起来的链接 title 图片链接 图片链接与上面的网址链接类似，同样有两种形式：行内式和参考式，只不过图片链接在前面加上一个感叹号!，在此不做累述。 行内式 ![huihut](http://ojlsgreog.bkt.clouddn.com/H_ya.png) 参考式 ![谷歌][1] [1]: https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png &quot;Google&quot; 指定图片宽高 Markdown 一般不支持指定图片的宽高，若要指定宽高可以使用普通的 &lt;img&gt; 标签 &lt;img src=&quot;./xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; 如果需要居中可以在外围包围div标签 &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; &lt;/div&gt; 使用支持指定图片大小的 Markdown 编辑器，如 Mou ![](xxx.png =100x100) 用图床获取外链 网上有许多图床，这里推荐两个 七牛图床 和 极简图床。 七牛图床 极简图床 进阶语法 标签 方法一 title: Markdown 简易入门教程 date: 2017-01-25 1:45:50 tags: Markdown categories: 技术 方法三 tags: - Markdown - 语言 categories: - 技术 方法三 tags: [Markdown,语言] categories: [技术] 目录 方法一 这种目录其实是用 HTML 加 Markdown的链接 实现，分为两个部分，目录部分和标题部分。 目录部分——实质是链接，链接的[地址]填需要跳转到的标题的id属性（自定义）。 [跳到标题一](#title1) 标题部分——实质是HTML的标题标签，标签里面的id属性等于待跳转的目录的[地址]。 &lt;h1 id=&quot;title1&quot;&gt;标题一&lt;/h1&gt; 方法二 这种方法非常简单，就是直接添加 [TOC]，标题1~6样式的内容会被提取出来作为目录，然而有些编辑器不能使用这功能，如 Mou 不能使用。我是在有道云笔记的 Markdown 中截图的。 [TOC] # 标题一 …… ## 标题二 …… ### 标题三 这里有个jQuery插件，貌似可以让Markdown生成目录： https://github.com/i5ting/i5ting_ztree_toc 表格 表格一般这样子写，这应该是最简单的写法了 id | name | score --- | --- | --- 001 | Mark | 90 002 | Ford | 80 003 | Alan | 95 还有就是对齐了，用:对齐，:写在在---的左边就是左对齐，右边就是右对齐，两边都写就是居中。 |long_long_id|long_long_name|long_long_score| | --- | :---: | ---: | | 001 | Mark | 90 | | 002 | Ford | 80 | | 003 | Alan | 95 | 脚注 这是脚注一[^1] [^1]: 脚注一 公式 方法一：使用Google Chart &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法二：使用forkosh &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法三：使用codecogs &lt;a href=&quot;https://www.codecogs.com/eqnedit.php?latex=x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/gif.latex?x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; title=&quot;x=\frac{-b\pm \sqrt{b^{2}-4ac}}{2a}&quot; /&gt;&lt;/a&gt; 方法四：使用MathJax引擎——先加载脚本&lt;script&gt;，后解析公式。 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 流程图 像流程图这种复杂的功能不推荐在 Markdown 中使用，因为很多编辑器都不支持，我使用了几个编辑器都不能生成流程图，所以上图是在为知笔记官方 Markdown 新手指南中找到的。 123456789st=&gt;start: Starte=&gt;end: Endop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?io=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1 更多关于流程图的语法说明： https://github.com/adrai/flowchart.js 序列图 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 更多关于时序图的语法说明： https://github.com/bramp/js-sequence-diagrams 其他语法 兼容HTML Markdown 可以和 HTML 混编，甚至可以完全用 HTML 语法来写。要注意在 HTML 标签中的 Markdown 代码是不起作用的。 &lt;font color=&apos;blue&apos; style=&apos;font-size:30px&apos;&gt;蓝色&lt;/font&gt; &lt;div&gt; # HTML 标签里面的 Markdown 语法不起作用 **你看我没有变粗** &lt;/div&gt; 特殊字符自动转换 HTML 语法——在 HTML 中所有&lt;和&amp;都要转换，包括链接（URL） 用 &amp;lt; 表示 &lt;——起始标签 用 &amp;amp; 表示 &amp; ——标记 HTML 实体 Markdown 语法——Markdown 则会自动转换 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号。如： *literal asterisks* 可用 \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 自动链接 网址自动链接 &lt;https://huihut.github.io/&gt; 电子邮件自动链接 &lt;huihut@outlook.com&gt; 感谢 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown——入门指南 Markdown语法手册 好用的Markdown编辑器一览 markdown中插入图片怎么定义图片的大小或比例？ Markdown进阶语法整理 为知笔记 Markdown 新手指南 Markdown中插入数学公式的方法 i5ting/i5ting_ztree_toc flowchart.js adrai/flowchart.js js-sequence-diagrams bramp/js-sequence-diagrams]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm自动安装pymysql包失败]]></title>
    <url>%2F2017%2F01%2F21%2FPyCharmInstallPymysqlFail%2F</url>
    <content type="text"><![CDATA[问题描述：在PyCharm中新建Web2Py项目后提示没有pymysql，自动安装失败，如图： 解决方案：1. 安装pip在终端输入 pip -V 如果显示版本路径，就说明pip已经安装了如果没有安装pip则需要在终端安装 ①使用脚本安装pip： 各平台（管理员运行）： python get-pip.py ②使用包管理器安装pip： Mac： sudo easy_install pip Debian &amp; Ubuntu: sudo apt-get install python-pip Fedora: sudo yum install python-pip 2. 安装pymysqlpip install pymysql 3. 正常情况下以上两步就行了。然而我的项目中依然提示没有pymysql，结果发现只是Python版本选错了(ノ▼Д▼)ノ我pymysql是安装到Python2.7，而PyCharm项目是用Python2.6所以就到Preferences &gt; Project Interpreter中调成Python2.7就行了， Thanks http://stackoverflow.com/questions/36956124/permision-issues-while-using-and-installing-python-packages]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工Shadowsocks安装及配置多用户(服务端)]]></title>
    <url>%2F2016%2F12%2F03%2FBandwagonShadowsocksServer%2F</url>
    <content type="text"><![CDATA[前言 Shadowsocks无GUI客户端教程：Linux安装配置Shadowsocks客户端及开机自动启动 Shadowsocks-Qt5客户端教程：Shadowsocks-Qt5 For Centos 7 Shadowsocks服务端教程：搬瓦工Shadowsocks安装及配置多用户(服务端) 安装Shadowsocks服务方案一： 搬瓦工VPS为我们准备了Shadowsocks的一键安装，直接在控制面板中有，非常方便。 只需在左边最下面选择Shadowsocks Server 然后选择Install Shadowsocks Server 等待安装完成后选择Go Back 现在可以看到加密协议默认aes-256-cfb,端口默认443 ,密码随机 如果是自己用，到这里就可以使用了，直接在客户端填好这些配置信息就好了。 方案二： 如果不在控制面板上安装或者是在其他没有一键安装的VPS上，可以使用命令安装。 Debian/Ubuntu: apt-get install python-pip pip install shadowsocks CentOS: yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks 优化Shadowsocks性能 在终端通过ssh连上vps（Windows可以用putty连，Mac直接在终端就可以了） 在终端输入vi /etc/sysctl.d/local.conf创建配置文件 按i插入 插入以下内容 # max open files fs.file-max = 1024000 # max read buffer net.core.rmem_max = 67108864 # max write buffer net.core.wmem_max = 67108864 # default read buffer net.core.rmem_default = 65536 # default write buffer net.core.wmem_default = 65536 # max processor input queue net.core.netdev_max_backlog = 4096 # max backlog net.core.somaxconn = 4096 # resist SYN flood attacks net.ipv4.tcp_syncookies = 1 # reuse timewait sockets when safe net.ipv4.tcp_tw_reuse = 1 # turn off fast timewait sockets recycling net.ipv4.tcp_tw_recycle = 0 # short FIN timeout net.ipv4.tcp_fin_timeout = 30 # short keepalive time net.ipv4.tcp_keepalive_time = 1200 # outbound port range net.ipv4.ip_local_port_range = 10000 65000 # max SYN backlog net.ipv4.tcp_max_syn_backlog = 4096 # max timewait sockets held by system simultaneously net.ipv4.tcp_max_tw_buckets = 5000 # TCP receive buffer net.ipv4.tcp_rmem = 4096 87380 67108864 # TCP write buffer net.ipv4.tcp_wmem = 4096 65536 67108864 # turn on path MTU discovery net.ipv4.tcp_mtu_probing = 1 # for high-latency network net.ipv4.tcp_congestion_control = hybla # forward ivp4 net.ipv4.ip_forward = 1 然后按Esc退出编辑，按shift+:，输入wq，回车，就保存退出了。 配置生效：sysctl --system 配置多用户如果想多用户使用的话就需要更改配置。 首先通过ssh连上vps 在终端输入vi /etc/shadowsocks.json创建配置文件 按i插入 插入以下内容（用户数任意，注意最后一个用户密码后面没有逗号） 1234567891011121314&#123; &quot;server&quot;:&quot;my_server_ip&quot;, #填入你的IP地址 &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;foobar1&quot;, #端口号，密码 &quot;8382&quot;: &quot;foobar2&quot;, &quot;8383&quot;: &quot;foobar3&quot;, &quot;8384&quot;: &quot;foobar4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 上面开了四个端口（用户）为8381-8384，密码分别为foobar1-foobar4，你还需要填入你的IP地址。 下面是详细配置说明： Name 说明 server 服务器地址，填ip或域名 local_address 本地地址 local_port 本地端口，一般1080，可任意 server_port 服务器对外开的端口 password 密码，可以每个服务器端口设置不同密码 port_password server_port + password ，服务器端口加密码的组合 timeout 超时重连 method 默认: “aes-256-cfb”，见 Encryption fast_open 开启或关闭 TCP_FASTOPEN, 填true / false，需要服务端支持 然后按Esc退出编辑，按shift+:，输入wq，回车，就保存退出了。 建议使用后端启动 前端启动：ssserver -c /etc/shadowsocks.json； 后端启动：ssserver -c /etc/shadowsocks.json -d start； 停止：ssserver -c /etc/shadowsocks.json -d stop； 重启(修改配置要重启才生效)：ssserver -c /etc/shadowsocks.json -d restart 设置开机启动 在终端输入vi /etc/rc.local， 把里面最后的带有ssserver的一大段默认的代码删除掉， 再把ssserver -c /etc/shadowsocks.json -d start加进去， 按wq保存退出。 到此就配置好了，试试多用户运行吧！ 修改2017年10月31日修改附上单用户的配置信息：/etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8381, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;foobar1&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
</search>
